diff --git a/LayoutTests/fast/mediastream/RTCPeerConnection-inspect-offer-expected.txt b/LayoutTests/fast/mediastream/RTCPeerConnection-inspect-offer-expected.txt
new file mode 100644
index 0000000..e875b5d
--- /dev/null
+++ b/LayoutTests/fast/mediastream/RTCPeerConnection-inspect-offer-expected.txt
@@ -0,0 +1,72 @@
+Inspect the result of RTCPeerConnection.createOffer()
+
+On success, you will see a series of "PASS" messages, followed by "TEST COMPLETE".
+
+
+PASS Got offer
+=== RTCSessionDescription ===
+type: offer, sdp:
+v=0
+o=- {session-id:OK} 0 IN IP4 127.0.0.1
+s=-
+t=0 0
+a=msid-semantic:WMS {media-stream-id:OK}
+m=audio 9 UDP/TLS/RTP/SAVPF 111 8 0
+c=IN IP4 0.0.0.0
+a=rtcp-mux
+a=sendrecv
+a=rtpmap:111 OPUS/48000/2
+a=rtpmap:8 PCMA/8000
+a=rtpmap:0 PCMU/8000
+a=ssrc:{ssrc:OK} cname:{cname:OK}
+a=msid:{media-stream-id:OK} {media-stream-track-id:OK}
+a=ice-ufrag:{ice-ufrag:OK}
+a=ice-pwd:{ice-password:OK}
+a=fingerprint:sha-256 8B:87:09:8A:5D:C2:F3:33:EF:C5:B1:F6:84:3A:3D:D6:A3:E2:9C:17:4C:E7:46:3B:1B:CE:84:98:DD:8E:AF:7B
+a=setup:actpass
+===
+
+PASS Got offer
+=== RTCSessionDescription ===
+type: offer, sdp:
+v=0
+o=- {session-id:OK} 1 IN IP4 127.0.0.1
+s=-
+t=0 0
+a=msid-semantic:WMS {media-stream-id:OK}
+m=audio 9 UDP/TLS/RTP/SAVPF 111 8 0
+c=IN IP4 0.0.0.0
+a=rtcp-mux
+a=sendrecv
+a=rtpmap:111 OPUS/48000/2
+a=rtpmap:8 PCMA/8000
+a=rtpmap:0 PCMU/8000
+a=ssrc:{ssrc:OK} cname:{cname:OK}
+a=msid:{media-stream-id:OK} {media-stream-track-id:OK}
+a=ice-ufrag:{ice-ufrag:OK}
+a=ice-pwd:{ice-password:OK}
+a=fingerprint:sha-256 8B:87:09:8A:5D:C2:F3:33:EF:C5:B1:F6:84:3A:3D:D6:A3:E2:9C:17:4C:E7:46:3B:1B:CE:84:98:DD:8E:AF:7B
+a=setup:actpass
+m=video 9 UDP/TLS/RTP/SAVPF 100 120
+c=IN IP4 0.0.0.0
+a=rtcp-mux
+a=sendrecv
+a=rtpmap:100 VP8/90000
+a=rtpmap:120 RTX/90000
+a=fmtp:120 apt=100;rtx-time=200
+a=rtcp-fb:100 nack
+a=rtcp-fb:100 nack pli
+a=rtcp-fb:100 ccm fir
+a=ssrc:{ssrc:OK} cname:{cname:OK}
+a=msid:{media-stream-id:OK} {media-stream-track-id:OK}
+a=ice-ufrag:{ice-ufrag:OK}
+a=ice-pwd:{ice-password:OK}
+a=fingerprint:sha-256 8B:87:09:8A:5D:C2:F3:33:EF:C5:B1:F6:84:3A:3D:D6:A3:E2:9C:17:4C:E7:46:3B:1B:CE:84:98:DD:8E:AF:7B
+a=setup:actpass
+===
+
+PASS End of promise chain
+PASS successfullyParsed is true
+
+TEST COMPLETE
+
diff --git a/LayoutTests/fast/mediastream/RTCPeerConnection-inspect-offer.html b/LayoutTests/fast/mediastream/RTCPeerConnection-inspect-offer.html
new file mode 100644
index 0000000..d1d5702
--- /dev/null
+++ b/LayoutTests/fast/mediastream/RTCPeerConnection-inspect-offer.html
@@ -0,0 +1,144 @@
+<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN">
+<html>
+    <head>
+        <script src="../../resources/js-test-pre.js"></script>
+    </head>
+    <body>
+        <script>
+            var stream;
+            var audioTrack;
+            var videoTrack;
+            var mediaDescriptionVariables = [];
+
+            description("Inspect the result of RTCPeerConnection.createOffer()");
+
+            if (window.testRunner)
+                testRunner.setUserMediaPermission(true);
+            else {
+                debug("This test can not be run without the testRunner");
+                finishJSTest();
+            }
+
+            var pc = new webkitRTCPeerConnection({iceServers:[{urls:'stun:foo.com'}]});
+
+            navigator.mediaDevices.getUserMedia({ "audio": true, "video": true })
+            .then(function (s) {
+                stream = s;
+                audioTrack = stream.getAudioTracks()[0];
+                videoTrack = stream.getVideoTracks()[0];
+
+                pc.addTrack(audioTrack, stream);
+                return pc.createOffer();
+            })
+            .then(function (offer) {
+                testPassed("Got offer");
+                mediaDescriptionVariables.push({ "trackId": audioTrack.id, "streamId": stream.id });
+                printComparableSessionDescription(offer, mediaDescriptionVariables);
+
+                pc.addTrack(videoTrack, stream);
+                return pc.createOffer();
+            })
+            .then(function (offer) {
+                testPassed("Got offer");
+                mediaDescriptionVariables.push({ "trackId": videoTrack.id, "streamId": stream.id });
+                printComparableSessionDescription(offer, mediaDescriptionVariables);
+
+                testPassed("End of promise chain");
+                finishJSTest();
+            })
+            .catch(function (error) {
+                testFailed("Error caught in promise chain: " + error);
+                finishJSTest();
+            });
+
+            // Variable fields (e.g. generated ids) are verified and replaced with predictable
+            // lables. The result can be compared with a predefined expected output.
+            function printComparableSessionDescription(sessionDescription, mdescVariables) {
+                debug("=== RTCSessionDescription ===");
+                debug("type: " + sessionDescription.type + ", sdp:");
+
+                var sdp = sessionDescription.sdp;
+
+                var regexp = {
+                    "oline": "^o=(-) ([\\d]+) .*$",
+                    "msidsemantic": "^a=msid-semantic: *WMS .*$",
+                    "mline": "^m=.*$",
+                    "cname": "^a=ssrc:(\\d+) cname:([\\w+/\\-@\\.\\{\\}]+).*$",
+                    "msid": "^a=(ssrc:\\d+ )?msid:([\\w+/\\-=]+) +([\\w+/\\-=]+).*$",
+                    "iceufrag": "^a=ice-ufrag:([\\w+/]*).*$",
+                    "icepwd": "^a=ice-pwd:([\\w+/]*=*).*$",
+                };
+
+                var mdescIndex = -1;
+                sdp.split("\r\n").forEach(function (line) {
+                    var mline;
+
+                    if (mline = match(line, regexp.mline)) {
+                        // Media block ("header" line)
+                        mdescIndex++;
+                    } else if (mdescIndex < 0) {
+                        // Session block
+                        var oline;
+                        var msidsemantic;
+
+                        if (oline = match(line, regexp.oline))
+                            line = line.replace(oline[2], verified("session-id"));
+                        else if (msidsemantic = match(line, regexp.msidsemantic)) {
+                            mdescVariables.forEach(function (variables) {
+                                line = line.replace(variables.streamId, verified("media-stream-id"));
+                            });
+                        }
+                    } else {
+                        // Media block (content lines)
+                        var cname;
+                        var msid;
+                        var iceufrag;
+                        var icepwd;
+
+                        if (cname = match(line, regexp.cname)) {
+                            line = line.replace(cname[1], verified("ssrc"));
+                            line = line.replace(cname[2], verified("cname"));
+
+                        } else if (msid = match(line, regexp.msid)) {
+                            if (msid[1])
+                                line = line.replace(msid[1], verified("ssrc"));
+
+                            var variables = mdescVariables[mdescIndex];
+
+                            var mediaStreamId = msid[2];
+                            var streamIdVerified = verified("media-stream-id", mediaStreamId != variables.streamId);
+                            line = line.replace(mediaStreamId, streamIdVerified);
+
+                            var mediaStreamTrackId = msid[3];
+                            var trackIdVerified = verified("media-stream-track-id", mediaStreamTrackId != variables.trackId);
+                            line = line.replace(mediaStreamTrackId, trackIdVerified);
+
+                        } else if (iceufrag = match(line, regexp.iceufrag))
+                            line = line.replace(iceufrag[1], verified("ice-ufrag"));
+                        else if (icepwd = match(line, regexp.icepwd))
+                            line = line.replace(icepwd[1], verified("ice-password"));
+                    }
+
+                    if (line)
+                        debug(line);
+                });
+
+                debug("===");
+                debug("");
+            }
+
+            function verified(name, isFailure) {
+                return "{" + name + ":" + (isFailure ? "FAILED" : "OK") + "}";
+            }
+
+            function match(data, pattern) {
+                return data.match(new RegExp(pattern));
+            }
+
+            window.jsTestIsAsync = true;
+            window.successfullyParsed = true;
+
+        </script>
+        <script src="../../resources/js-test-post.js"></script>
+    </body>
+</html>
diff --git a/Source/WebCore/CMakeLists.txt b/Source/WebCore/CMakeLists.txt
index e531987..26f1aac 100644
--- a/Source/WebCore/CMakeLists.txt
+++ b/Source/WebCore/CMakeLists.txt
@@ -226,7 +226,6 @@ set(WebCore_NON_SVG_IDL_FILES
     Modules/mediastream/MediaDeviceInfo.idl
     Modules/mediastream/MediaDevices.idl
     Modules/mediastream/MediaStream.idl
-    Modules/mediastream/MediaStreamEvent.idl
     Modules/mediastream/MediaStreamTrack.idl
     Modules/mediastream/MediaStreamTrackEvent.idl
     Modules/mediastream/MediaStreamTrackSourcesCallback.idl
@@ -948,7 +947,6 @@ set(WebCore_SOURCES
     Modules/mediastream/MediaEndpointPeerConnection.cpp
     Modules/mediastream/MediaSourceSettings.cpp
     Modules/mediastream/MediaStream.cpp
-    Modules/mediastream/MediaStreamEvent.cpp
     Modules/mediastream/MediaStreamRegistry.cpp
     Modules/mediastream/MediaStreamTrack.cpp
     Modules/mediastream/MediaStreamTrackEvent.cpp
@@ -972,6 +970,7 @@ set(WebCore_SOURCES
     Modules/mediastream/RTCStatsReport.cpp
     Modules/mediastream/RTCStatsResponse.cpp
     Modules/mediastream/RTCTrackEvent.cpp
+    Modules/mediastream/SDPProcessor.cpp
     Modules/mediastream/SourceInfo.cpp
     Modules/mediastream/UserMediaController.cpp
     Modules/mediastream/UserMediaPermissionCheck.cpp
@@ -2292,6 +2291,7 @@ set(WebCore_SOURCES
     platform/graphics/transforms/TransformationMatrix.cpp
     platform/graphics/transforms/TranslateTransformOperation.cpp
 
+    platform/mediastream/MediaEndpointInit.cpp
     platform/mediastream/MediaStreamPrivate.cpp
     platform/mediastream/MediaStreamTrackPrivate.cpp
     platform/mediastream/RTCIceCandidateDescriptor.cpp
@@ -2305,6 +2305,7 @@ set(WebCore_SOURCES
     platform/mock/DeviceOrientationClientMock.cpp
     platform/mock/GeolocationClientMock.cpp
     platform/mock/MediaConstraintsMock.cpp
+    platform/mock/MockMediaEndpoint.cpp
     platform/mock/MockRealtimeAudioSource.cpp
     platform/mock/MockRealtimeMediaSource.cpp
     platform/mock/MockRealtimeMediaSourceCenter.cpp
@@ -3512,6 +3513,22 @@ if (WebCore_USER_AGENT_SCRIPTS)
     ADD_SOURCE_WEBCORE_DERIVED_DEPENDENCIES(${WebCore_USER_AGENT_SCRIPTS_DEPENDENCIES} UserAgentScriptsData.cpp UserAgentScripts.h)
 endif ()
 
+if (WebCore_SDP_PROCESSOR_SCRIPTS)
+    # Necessary variables:
+    # WebCore_SDP_PROCESSOR_SCRIPTS containing the JavaScript sources list
+    # WebCore_SDP_PROCESSOR_SCRIPTS_DEPENDENCIES containing the source file that will load the scripts to add the proper
+    #   dependency and having them built at the right moment
+
+    add_custom_command(
+        OUTPUT ${DERIVED_SOURCES_WEBCORE_DIR}/SDPProcessorScriptsData.cpp ${DERIVED_SOURCES_WEBCORE_DIR}/SDPProcessorScripts.h
+        MAIN_DEPENDENCY ${WEBCORE_DIR}/Scripts/make-js-file-arrays.py
+        DEPENDS ${WebCore_SDP_PROCESSOR_SCRIPTS}
+        COMMAND "PYTHONPATH=${JavaScriptCore_SCRIPTS_DIR}" ${PYTHON_EXECUTABLE} ${WEBCORE_DIR}/Scripts/make-js-file-arrays.py ${DERIVED_SOURCES_WEBCORE_DIR}/SDPProcessorScripts.h ${DERIVED_SOURCES_WEBCORE_DIR}/SDPProcessorScriptsData.cpp ${WebCore_SDP_PROCESSOR_SCRIPTS}
+        VERBATIM)
+    list(APPEND WebCore_SOURCES ${DERIVED_SOURCES_WEBCORE_DIR}/SDPProcessorScriptsData.cpp)
+    ADD_SOURCE_WEBCORE_DERIVED_DEPENDENCIES(${WebCore_SDP_PROCESSOR_SCRIPTS_DEPENDENCIES} SDPProcessorScriptsData.cpp SDPProcessorScripts.h)
+endif ()
+
 # Generate plug-in resources
 add_custom_command(
     OUTPUT ${DERIVED_SOURCES_WEBCORE_DIR}/PlugInsResourcesData.cpp ${DERIVED_SOURCES_WEBCORE_DIR}/PlugInsResources.h
diff --git a/Source/WebCore/Modules/mediastream/MediaEndpointPeerConnection.cpp b/Source/WebCore/Modules/mediastream/MediaEndpointPeerConnection.cpp
index ea25eb2..89b283c 100644
--- a/Source/WebCore/Modules/mediastream/MediaEndpointPeerConnection.cpp
+++ b/Source/WebCore/Modules/mediastream/MediaEndpointPeerConnection.cpp
@@ -33,12 +33,30 @@
 #if ENABLE(MEDIA_STREAM)
 #include "MediaEndpointPeerConnection.h"
 
+#include "CryptoDigest.h"
 #include "DOMError.h"
 #include "JSDOMError.h"
+#include "JSRTCSessionDescription.h"
+#include "MediaStreamTrack.h"
+#include "PeerConnectionBackend.h"
+#include "PeerMediaDescription.h"
+#include "RTCConfiguration.h"
+#include "RTCIceCandidate.h"
+#include "RTCIceCandidateEvent.h"
+#include "RTCOfferAnswerOptions.h"
+#include "RTCSessionDescription.h"
+#include "RTCRtpReceiver.h"
+#include "RTCRtpSender.h"
+#include "RTCTrackEvent.h"
+#include "SDPProcessor.h"
+#include "UUID.h"
+#include <wtf/MainThread.h>
+#include <wtf/text/Base64.h>
 
 namespace WebCore {
 
 using namespace PeerConnection;
+using namespace PeerConnectionStates;
 
 static std::unique_ptr<PeerConnectionBackend> createMediaEndpointPeerConnection(PeerConnectionBackendClient* client)
 {
@@ -47,120 +65,849 @@ static std::unique_ptr<PeerConnectionBackend> createMediaEndpointPeerConnection(
 
 CreatePeerConnectionBackend PeerConnectionBackend::create = createMediaEndpointPeerConnection;
 
+class WrappedSessionDescriptionPromise : public RefCounted<WrappedSessionDescriptionPromise> {
+public:
+    static Ref<WrappedSessionDescriptionPromise> create(SessionDescriptionPromise&& promise)
+    {
+        return *adoptRef(new WrappedSessionDescriptionPromise(WTF::move(promise)));
+    }
+
+    SessionDescriptionPromise& promise() { return m_promise; }
+
+private:
+    WrappedSessionDescriptionPromise(SessionDescriptionPromise&& promise)
+        : m_promise(WTF::move(promise))
+    { }
+
+    SessionDescriptionPromise m_promise;
+};
+
+class WrappedVoidPromise : public RefCounted<WrappedVoidPromise> {
+public:
+    static Ref<WrappedVoidPromise> create(VoidPromise&& promise)
+    {
+        return *adoptRef(new WrappedVoidPromise(WTF::move(promise)));
+    }
+
+    VoidPromise& promise() { return m_promise; }
+
+private:
+    WrappedVoidPromise(VoidPromise&& promise)
+        : m_promise(WTF::move(promise))
+    { }
+
+    VoidPromise m_promise;
+};
+
+static String randomString(size_t length)
+{
+    const size_t size = ceil(length * 3 / 4);
+    unsigned char randomValues[size];
+    cryptographicallyRandomValues(randomValues, size);
+    return base64Encode(randomValues, size);
+}
+
+static RefPtr<MediaEndpointInit> createMediaEndpointInit(RTCConfiguration& rtcConfig)
+{
+    Vector<RefPtr<IceServerInfo>> iceServers;
+    for (auto& server : rtcConfig.iceServers())
+        iceServers.append(IceServerInfo::create(server->urls(), server->credential(), server->username()));
+
+    return MediaEndpointInit::create(iceServers, rtcConfig.iceTransportPolicy(), rtcConfig.bundlePolicy());
+}
+
 MediaEndpointPeerConnection::MediaEndpointPeerConnection(PeerConnectionBackendClient* client)
+    : m_client(client)
+    , m_sdpProcessor(std::unique_ptr<SDPProcessor>(new SDPProcessor(m_client->scriptExecutionContext())))
+    , m_cname(randomString(16))
+    , m_iceUfrag(randomString(4))
+    , m_icePassword(randomString(22))
+    , m_sdpSessionVersion(0)
+    , m_negotiationNeeded(false)
 {
-    UNUSED_PARAM(client);
+    m_mediaEndpoint = MediaEndpoint::create(this);
+    ASSERT(m_mediaEndpoint);
+
+    m_defaultAudioPayloads = m_mediaEndpoint->getDefaultAudioPayloads();
+    m_defaultVideoPayloads = m_mediaEndpoint->getDefaultVideoPayloads();
+
+    m_mediaEndpoint->getDtlsFingerprint();
+}
+
+MediaEndpointPeerConnection::~MediaEndpointPeerConnection()
+{
+}
+
+static size_t indexOfSenderWithTrackId(const RtpSenderVector& senders, const String& trackId)
+{
+    for (size_t i = 0; i < senders.size(); ++i) {
+        if (senders[i]->trackId() == trackId)
+            return i;
+    }
+    return notFound;
+}
+
+static size_t indexOfMediaDescriptionWithTrackId(const MediaDescriptionVector& mediaDescriptions, const String& trackId)
+{
+    for (size_t i = 0; i < mediaDescriptions.size(); ++i) {
+        if (mediaDescriptions[i]->mediaStreamTrackId() == trackId)
+            return i;
+    }
+    return notFound;
+}
+
+static RefPtr<RTCRtpSender> takeFirstSenderOfType(RtpSenderVector& senders, const String& type)
+{
+    for (unsigned i = 0; i < senders.size(); ++i) {
+        if (senders[i]->track()->kind() == type) {
+            RefPtr<RTCRtpSender> sender = senders[i];
+            senders.remove(i);
+            return sender;
+        }
+    }
+    return nullptr;
+}
+
+static void updateMediaDescriptionsWithSenders(const MediaDescriptionVector& mediaDescriptions, RtpSenderVector& senders)
+{
+    // Remove any sender(s) from the senders list that already have their tracks represented by a media
+    // description. Mark media descriptions that don't have a sender/track (anymore) as "available".
+    for (auto& mdesc : mediaDescriptions) {
+        const String& mdescTrackId = mdesc->mediaStreamTrackId();
+        size_t index = indexOfSenderWithTrackId(senders, mdescTrackId);
+        if (index != notFound)
+            senders.remove(index);
+        else {
+            mdesc->setMediaStreamId(emptyString());
+            mdesc->setMediaStreamTrackId(emptyString());
+            mdesc->clearSsrcs();
+        }
+    }
+
+    // Remove any sender(s) from the senders list that can be matched (by track type) to an "available"
+    // media description. Mark media descriptions that don't get matched with a sender as receive only.
+    for (auto& mdesc : mediaDescriptions) {
+        if (mdesc->mediaStreamTrackId() != emptyString())
+            continue;
+
+        RefPtr<RTCRtpSender> sender = takeFirstSenderOfType(senders, mdesc->type());
+        if (sender) {
+            // FIXME: what else needs to be updated to reuse a media description?
+            mdesc->setMediaStreamId(sender->mediaStreamIds()[0]);
+            mdesc->setMediaStreamTrackId(sender->trackId());
+            mdesc->addSsrc(cryptographicallyRandomNumber());
+            mdesc->setMode("sendrecv");
+        } else
+            mdesc->setMode("recvonly");
+    }
+}
+
+void MediaEndpointPeerConnection::runTask(std::function<void ()> task)
+{
+    // Don't run any tasks until the async initialization is done.
+    if (m_dtlsFingerprint.isNull()) {
+        // Only one task needs to be deferred since it will hold off any others until completed.
+        ASSERT(!m_initialDeferredTask);
+        m_initialDeferredTask = task;
+    }
+    else
+        callOnMainThread(task);
+}
+
+void MediaEndpointPeerConnection::startRunningTasks()
+{
+    if (!m_initialDeferredTask)
+        return;
+
+    m_initialDeferredTask();
+    m_initialDeferredTask = nullptr;
 }
 
 void MediaEndpointPeerConnection::createOffer(RTCOfferOptions& options, SessionDescriptionPromise&& promise)
 {
-    UNUSED_PARAM(options);
+    const RefPtr<RTCOfferOptions> protectedOptions = &options;
+    RefPtr<WrappedSessionDescriptionPromise> wrappedPromise = WrappedSessionDescriptionPromise::create(WTF::move(promise));
 
-    notImplemented();
+    runTask([this, protectedOptions, wrappedPromise]() {
+        createOfferTask(*protectedOptions, wrappedPromise->promise());
+    });
+}
 
-    promise.reject(DOMError::create("NotSupportedError"));
+void MediaEndpointPeerConnection::createOfferTask(RTCOfferOptions& options, SessionDescriptionPromise& promise)
+{
+    ASSERT(!m_dtlsFingerprint.isEmpty());
+
+    RefPtr<MediaEndpointConfiguration> configurationSnapshot = internalLocalDescription() ?
+        internalLocalDescription()->configuration()->clone() : MediaEndpointConfiguration::create();
+
+    configurationSnapshot->setSessionVersion(m_sdpSessionVersion++);
+
+    RtpSenderVector senders = m_client->getSenders();
+    updateMediaDescriptionsWithSenders(configurationSnapshot->mediaDescriptions(), senders);
+
+    // Add media descriptions for remaining senders.
+    for (auto& sender : senders) {
+        RefPtr<PeerMediaDescription> mediaDescription = PeerMediaDescription::create();
+        MediaStreamTrack* track = sender->track();
+
+        mediaDescription->setMediaStreamId(sender->mediaStreamIds()[0]);
+        mediaDescription->setMediaStreamTrackId(track->id());
+        mediaDescription->setType(track->kind());
+        mediaDescription->setPort(9);
+        mediaDescription->setAddress("0.0.0.0");
+        mediaDescription->setMode("sendrecv");
+        mediaDescription->setPayloads(track->kind() == "audio" ? m_defaultAudioPayloads : m_defaultVideoPayloads);
+        mediaDescription->setRtcpMux(true);
+        mediaDescription->setDtlsSetup("actpass");
+        mediaDescription->setDtlsFingerprintHashFunction(m_dtlsFingerprintFunction);
+        mediaDescription->setDtlsFingerprint(m_dtlsFingerprint);
+        mediaDescription->setCname(m_cname);
+        mediaDescription->addSsrc(cryptographicallyRandomNumber());
+        mediaDescription->setIceUfrag(m_iceUfrag);
+        mediaDescription->setIcePassword(m_icePassword);
+
+        configurationSnapshot->addMediaDescription(WTF::move(mediaDescription));
+    }
+
+    int extraMediaDescriptionCount = options.offerToReceiveAudio() + options.offerToReceiveVideo();
+    for (int i = 0; i < extraMediaDescriptionCount; ++i) {
+        String type = i < options.offerToReceiveAudio() ? "audio" : "video";
+        RefPtr<PeerMediaDescription> mediaDescription = PeerMediaDescription::create();
+
+        mediaDescription->setType(type);
+        mediaDescription->setPort(9);
+        mediaDescription->setAddress("0.0.0.0");
+        mediaDescription->setMode("recvonly");
+        mediaDescription->setPayloads(type == "audio" ? m_defaultAudioPayloads : m_defaultVideoPayloads);
+        mediaDescription->setRtcpMux(true);
+        mediaDescription->setDtlsSetup("actpass");
+        mediaDescription->setDtlsFingerprintHashFunction(m_dtlsFingerprintFunction);
+        mediaDescription->setDtlsFingerprint(m_dtlsFingerprint);
+        mediaDescription->setIceUfrag(m_iceUfrag);
+        mediaDescription->setIcePassword(m_icePassword);
+
+        configurationSnapshot->addMediaDescription(WTF::move(mediaDescription));
+    }
+
+    // FIXME: Handle empty string return value from SDPProcessor
+    RefPtr<RTCSessionDescription> offer = RTCSessionDescription::create("offer", m_sdpProcessor->generate(*configurationSnapshot));
+
+    promise.resolve(offer);
 }
 
 void MediaEndpointPeerConnection::createAnswer(RTCAnswerOptions& options, SessionDescriptionPromise&& promise)
 {
-    UNUSED_PARAM(options);
+    const RefPtr<RTCAnswerOptions> protectedOptions = &options;
+    RefPtr<WrappedSessionDescriptionPromise> wrappedPromise = WrappedSessionDescriptionPromise::create(WTF::move(promise));
+
+    runTask([this, protectedOptions, wrappedPromise]() {
+        createAnswerTask(*protectedOptions, wrappedPromise->promise());
+    });
+}
+
+void MediaEndpointPeerConnection::createAnswerTask(RTCAnswerOptions&, SessionDescriptionPromise& promise)
+{
+    ASSERT(!m_dtlsFingerprint.isEmpty());
+
+    if (!remoteDescription()) {
+        // FIXME: Error type?
+        promise.reject(DOMError::create("InvalidStateError (no remote description)"));
+        return;
+    }
+
+    RefPtr<MediaEndpointConfiguration> configurationSnapshot = internalLocalDescription() ?
+        internalLocalDescription()->configuration()->clone() : MediaEndpointConfiguration::create();
+
+    configurationSnapshot->setSessionVersion(m_sdpSessionVersion++);
+
+    const MediaDescriptionVector& remoteMediaDescriptions = internalRemoteDescription()->configuration()->mediaDescriptions();
+    for (unsigned i = 0; i < remoteMediaDescriptions.size(); ++i) {
+        RefPtr<PeerMediaDescription> remoteMediaDescription = remoteMediaDescriptions[i];
+        RefPtr<PeerMediaDescription> localMediaDescription;
+
+        if (i < configurationSnapshot->mediaDescriptions().size())
+            localMediaDescription = configurationSnapshot->mediaDescriptions()[i];
+        else {
+            localMediaDescription = PeerMediaDescription::create();
+            localMediaDescription->setType(remoteMediaDescription->type());
+            localMediaDescription->setPort(9);
+            localMediaDescription->setAddress("0.0.0.0");
+            localMediaDescription->setDtlsSetup(remoteMediaDescription->dtlsSetup() == "active" ? "passive" : "active");
+            localMediaDescription->setDtlsFingerprintHashFunction(m_dtlsFingerprintFunction);
+            localMediaDescription->setDtlsFingerprint(m_dtlsFingerprint);
+            localMediaDescription->setCname(m_cname);
+            localMediaDescription->setIceUfrag(m_iceUfrag);
+            localMediaDescription->setIcePassword(m_icePassword);
+
+            configurationSnapshot->addMediaDescription(localMediaDescription.copyRef());
+        }
+
+        localMediaDescription->setPayloads(remoteMediaDescription->payloads());
+
+        localMediaDescription->setRtcpMux(remoteMediaDescription->rtcpMux());
+
+        if (!localMediaDescription->ssrcs().size())
+            localMediaDescription->addSsrc(cryptographicallyRandomNumber());
 
-    notImplemented();
+        if (localMediaDescription->dtlsSetup() == "actpass")
+            localMediaDescription->setDtlsSetup("passive");
+    }
 
-    promise.reject(DOMError::create("NotSupportedError"));
+    RtpSenderVector senders = m_client->getSenders();
+    updateMediaDescriptionsWithSenders(configurationSnapshot->mediaDescriptions(), senders);
+
+    RefPtr<RTCSessionDescription> answer = RTCSessionDescription::create("answer", m_sdpProcessor->generate(*configurationSnapshot));
+
+    promise.resolve(answer);
 }
 
 void MediaEndpointPeerConnection::setLocalDescription(RTCSessionDescription& description, VoidPromise&& promise)
 {
-    UNUSED_PARAM(description);
+    RefPtr<RTCSessionDescription> protectedDescription = &description;
+    RefPtr<WrappedVoidPromise> wrappedPromise = WrappedVoidPromise::create(WTF::move(promise));
 
-    notImplemented();
+    runTask([this, protectedDescription, wrappedPromise]() {
+        setLocalDescriptionTask(*protectedDescription, wrappedPromise->promise());
+    });
+}
+
+static void updateSendSources(const MediaDescriptionVector& localMediaDescriptions, const MediaDescriptionVector& remoteMediaDescriptions, const RtpSenderVector& senders)
+{
+    for (unsigned i = 0; i < remoteMediaDescriptions.size(); ++i) {
+        if (remoteMediaDescriptions[i]->type() != "audio" && remoteMediaDescriptions[i]->type() != "video")
+            continue;
 
-    promise.reject(DOMError::create("NotSupportedError"));
+        if (localMediaDescriptions.size() <= i)
+            return;
+
+        size_t index = indexOfSenderWithTrackId(senders, localMediaDescriptions[i]->mediaStreamTrackId());
+        if (index != notFound)
+            remoteMediaDescriptions[i]->setSource(senders[index]->track()->source());
+    }
 }
 
-RefPtr<RTCSessionDescription> MediaEndpointPeerConnection::localDescription() const
+static bool allSendersRepresented(const RtpSenderVector& senders, const MediaDescriptionVector& mediaDescriptions)
 {
-    notImplemented();
+    for (auto& sender : senders) {
+        if (indexOfMediaDescriptionWithTrackId(mediaDescriptions, sender->trackId()) == notFound)
+            return false;
+    }
+    return true;
+}
 
-    return nullptr;
+void MediaEndpointPeerConnection::setLocalDescriptionTask(RTCSessionDescription& description, VoidPromise& promise)
+{
+    SessionDescription::Type descriptionType = parseDescriptionType(description.type());
+
+    if (!localDescriptionTypeValidForState(descriptionType)) {
+        // FIXME: Error type?
+        promise.reject(DOMError::create("InvalidSessionDescriptionError (bad description type for current state)"));
+        return;
+    }
+
+    RefPtr<MediaEndpointConfiguration> parsedConfiguration = m_sdpProcessor->parse(description.sdp());
+    if (!parsedConfiguration) {
+        // FIXME: Error type?
+        promise.reject(DOMError::create("InvalidSessionDescriptionError (unable to parse description)"));
+        return;
+    }
+
+    unsigned previousNumberOfMediaDescriptions = internalLocalDescription() ? internalLocalDescription()->configuration()->mediaDescriptions().size() : 0;
+    unsigned numberOfMediaDescriptions = parsedConfiguration->mediaDescriptions().size();
+    bool hasNewMediaDescriptions = numberOfMediaDescriptions > previousNumberOfMediaDescriptions;
+    bool isInitiator = descriptionType == SessionDescription::Type::Offer;
+
+    if (hasNewMediaDescriptions) {
+        MediaEndpointPrepareResult prepareResult = m_mediaEndpoint->prepareToReceive(parsedConfiguration.get(), isInitiator);
+
+        if (prepareResult == MediaEndpointPrepareResult::SuccessWithIceRestart) {
+            if (m_client->internalIceGatheringState() != IceGatheringState::Gathering)
+                m_client->updateIceGatheringState(IceGatheringState::Gathering);
+
+            if (m_client->internalIceConnectionState() != IceConnectionState::Completed)
+                m_client->updateIceConnectionState(IceConnectionState::Connected);
+
+            printf("ICE restart not implemented\n");
+
+        } else if (prepareResult == MediaEndpointPrepareResult::Failed) {
+            // FIXME: Error type?
+            promise.reject(DOMError::create("IncompatibleSessionDescriptionError (receive configuration)"));
+            return;
+        }
+    }
+
+    if (internalRemoteDescription()) {
+        updateSendSources(parsedConfiguration->mediaDescriptions(), internalRemoteDescription()->configuration()->mediaDescriptions(), m_client->getSenders());
+
+        if (m_mediaEndpoint->prepareToSend(internalRemoteDescription()->configuration(), isInitiator) == MediaEndpointPrepareResult::Failed) {
+            // FIXME: Error type?
+            promise.reject(DOMError::create("IncompatibleSessionDescriptionError (send configuration)"));
+            return;
+        }
+    }
+
+    if (allSendersRepresented(m_client->getSenders(), parsedConfiguration->mediaDescriptions()))
+        clearNegotiationNeededState();
+
+    RefPtr<SessionDescription> newDescription = SessionDescription::create(descriptionType, WTF::move(parsedConfiguration));
+    SignalingState newSignalingState;
+
+    // Update state and local descriptions according to setLocal/RemoteDescription processing model
+    switch (newDescription->type()) {
+    case SessionDescription::Type::Offer:
+        if (newDescription->isLaterThan(m_currentLocalDescription.get())) {
+            m_pendingLocalDescription = newDescription;
+            newSignalingState = SignalingState::HaveLocalOffer;
+        }
+
+        break;
+
+    case SessionDescription::Type::Answer:
+        m_currentLocalDescription = newDescription;
+        m_currentRemoteDescription = m_pendingRemoteDescription;
+        m_pendingLocalDescription = nullptr;
+        m_pendingRemoteDescription = nullptr;
+        newSignalingState = SignalingState::Stable;
+        break;
+
+    case SessionDescription::Type::Rollback:
+        // FIXME: rollback is not supported in the platform yet
+        m_pendingLocalDescription = nullptr;
+        newSignalingState = SignalingState::Stable;
+        break;
+
+    case SessionDescription::Type::Pranswer:
+        m_pendingLocalDescription = newDescription;
+        newSignalingState = SignalingState::HaveLocalPrAnswer;
+        break;
+    }
+
+    if (newSignalingState != m_client->internalSignalingState()) {
+        m_client->setSignalingState(newSignalingState);
+        m_client->fireEvent(Event::create(eventNames().signalingstatechangeEvent, false, false));
+    }
+
+    // FIXME: do this even if an ice start was done?
+    if (m_client->internalIceGatheringState() == IceGatheringState::New && numberOfMediaDescriptions)
+        m_client->updateIceGatheringState(IceGatheringState::Gathering);
+
+    if (m_client->internalSignalingState() == SignalingState::Stable && m_negotiationNeeded)
+        m_client->scheduleNegotiationNeededEvent();
+
+    promise.resolve(nullptr);
 }
 
-RefPtr<RTCSessionDescription> MediaEndpointPeerConnection::currentLocalDescription() const
+RefPtr<RTCSessionDescription> MediaEndpointPeerConnection::localDescription() const
 {
-    notImplemented();
+    return createRTCSessionDescription(internalLocalDescription());
+}
 
-    return nullptr;
+RefPtr<RTCSessionDescription> MediaEndpointPeerConnection::currentLocalDescription() const
+{
+    return createRTCSessionDescription(m_currentLocalDescription.get());
 }
 
 RefPtr<RTCSessionDescription> MediaEndpointPeerConnection::pendingLocalDescription() const
 {
-    notImplemented();
+    return createRTCSessionDescription(m_pendingLocalDescription.get());
+}
 
-    return nullptr;
+static Vector<RefPtr<MediaPayload>> filterPayloads(const Vector<RefPtr<MediaPayload>>& remotePayloads, const Vector<RefPtr<MediaPayload>>& defaultPayloads)
+{
+    Vector<RefPtr<MediaPayload>> filteredPayloads;
+
+    for (auto& remotePayload : remotePayloads) {
+        MediaPayload* defaultPayload = nullptr;
+        for (auto& p : defaultPayloads) {
+            if (p->encodingName() == remotePayload->encodingName().upper()) {
+                defaultPayload = p.get();
+                break;
+            }
+        }
+        if (!defaultPayload)
+            continue;
+
+        if (defaultPayload->parameters().contains("packetizationMode") && remotePayload->parameters().contains("packetizationMode")
+            && (defaultPayload->parameters().get("packetizationMode") != defaultPayload->parameters().get("packetizationMode")))
+            continue;
+
+        filteredPayloads.append(remotePayload);
+    }
+
+    return filteredPayloads;
 }
 
 void MediaEndpointPeerConnection::setRemoteDescription(RTCSessionDescription& description, VoidPromise&& promise)
 {
-    UNUSED_PARAM(description);
+    RefPtr<RTCSessionDescription> protectedDescription = &description;
+    RefPtr<WrappedVoidPromise> wrappedPromise = WrappedVoidPromise::create(WTF::move(promise));
 
-    notImplemented();
+    runTask([this, protectedDescription, wrappedPromise]() {
+        setRemoteDescriptionTask(*protectedDescription, wrappedPromise->promise());
+    });
+}
 
-    promise.reject(DOMError::create("NotSupportedError"));
+void MediaEndpointPeerConnection::setRemoteDescriptionTask(RTCSessionDescription& description, VoidPromise& promise)
+{
+    SessionDescription::Type descriptionType = parseDescriptionType(description.type());
+
+    if (!remoteDescriptionTypeValidForState(descriptionType)) {
+        // FIXME: Error type?
+        promise.reject(DOMError::create("InvalidSessionDescriptionError (bad description type for current state)"));
+        return;
+    }
+
+    RefPtr<MediaEndpointConfiguration> parsedConfiguration = m_sdpProcessor->parse(description.sdp());
+    if (!parsedConfiguration) {
+        // FIXME: Error type?
+        promise.reject(DOMError::create("InvalidSessionDescriptionError (unable to parse description)"));
+        return;
+    }
+
+    RtpSenderVector senders = m_client->getSenders();
+
+    for (auto& mediaDescription : parsedConfiguration->mediaDescriptions()) {
+        if (mediaDescription->type() != "audio" && mediaDescription->type() != "video")
+            continue;
+
+        mediaDescription->setPayloads(filterPayloads(mediaDescription->payloads(),
+            mediaDescription->type() == "audio" ? m_defaultAudioPayloads : m_defaultVideoPayloads));
+    }
+
+    bool isInitiator = descriptionType == SessionDescription::Type::Answer;
+
+    if (internalLocalDescription())
+        updateSendSources(internalLocalDescription()->configuration()->mediaDescriptions(), parsedConfiguration->mediaDescriptions(), senders);
+
+    if (m_mediaEndpoint->prepareToSend(parsedConfiguration.get(), isInitiator) == MediaEndpointPrepareResult::Failed) {
+        // FIXME: Error type?
+        promise.reject(DOMError::create("IncompatibleSessionDescriptionError (send configuration)"));
+        return;
+    }
+
+    RefPtr<SessionDescription> newDescription = SessionDescription::create(descriptionType, WTF::move(parsedConfiguration));
+    SignalingState newSignalingState;
+
+    // Update state and local descriptions according to setLocal/RemoteDescription processing model
+    switch (newDescription->type()) {
+    case SessionDescription::Type::Offer:
+        if (newDescription->isLaterThan(m_currentRemoteDescription.get())) {
+            m_pendingRemoteDescription = newDescription;
+            newSignalingState = SignalingState::HaveRemoteOffer;
+        }
+        break;
+
+    case SessionDescription::Type::Answer:
+        m_currentRemoteDescription = newDescription;
+        m_currentLocalDescription = m_pendingLocalDescription;
+        m_pendingRemoteDescription = nullptr;
+        m_pendingLocalDescription = nullptr;
+        newSignalingState = SignalingState::Stable;
+        break;
+
+    case SessionDescription::Type::Rollback:
+        // FIXME: rollback is not supported in the platform yet
+        m_pendingRemoteDescription = nullptr;
+        newSignalingState = SignalingState::Stable;
+        break;
+
+    case SessionDescription::Type::Pranswer:
+        m_pendingRemoteDescription = newDescription;
+        newSignalingState = SignalingState::HaveRemotePrAnswer;
+        break;
+    }
+
+    if (newSignalingState != m_client->internalSignalingState()) {
+        m_client->setSignalingState(newSignalingState);
+        m_client->fireEvent(Event::create(eventNames().signalingstatechangeEvent, false, false));
+    }
+
+    promise.resolve(nullptr);
 }
 
 RefPtr<RTCSessionDescription> MediaEndpointPeerConnection::remoteDescription() const
 {
-    notImplemented();
-
-    return nullptr;
+    return createRTCSessionDescription(internalRemoteDescription());
 }
 
 RefPtr<RTCSessionDescription> MediaEndpointPeerConnection::currentRemoteDescription() const
 {
-    notImplemented();
-
-    return nullptr;
+    return createRTCSessionDescription(m_currentRemoteDescription.get());
 }
 
 RefPtr<RTCSessionDescription> MediaEndpointPeerConnection::pendingRemoteDescription() const
 {
-    notImplemented();
-
-    return nullptr;
+    return createRTCSessionDescription(m_pendingRemoteDescription.get());
 }
 
 void MediaEndpointPeerConnection::setConfiguration(RTCConfiguration& configuration)
 {
-    UNUSED_PARAM(configuration);
-
-    notImplemented();
+    // FIXME: updateIce() might be renamed to setConfiguration(). It's also possible
+    // that its current behavior with update deltas will change.
+    m_mediaEndpoint->setConfiguration(createMediaEndpointInit(configuration));
 }
 
 void MediaEndpointPeerConnection::addIceCandidate(RTCIceCandidate& rtcCandidate, PeerConnection::VoidPromise&& promise)
 {
-    UNUSED_PARAM(rtcCandidate);
+    RefPtr<RTCIceCandidate> protectedCandidate = &rtcCandidate;
+    RefPtr<WrappedVoidPromise> wrappedPromise = WrappedVoidPromise::create(WTF::move(promise));
 
-    notImplemented();
+    runTask([this, protectedCandidate, wrappedPromise]() {
+        addIceCandidateTask(*protectedCandidate, wrappedPromise->promise());
+    });
+}
 
-    promise.reject(DOMError::create("NotSupportedError"));
+void MediaEndpointPeerConnection::addIceCandidateTask(RTCIceCandidate& rtcCandidate, PeerConnection::VoidPromise& promise)
+{
+    if (!remoteDescription()) {
+        // FIXME: Error type?
+        promise.reject(DOMError::create("InvalidStateError (no remote description)"));
+        return;
+    }
+
+    RefPtr<IceCandidate> candidate = m_sdpProcessor->parseCandidateLine(rtcCandidate.candidate());
+    if (!candidate) {
+        // FIXME: Error type?
+        promise.reject(DOMError::create("SyntaxError (malformed candidate)"));
+        return;
+    }
+
+    const MediaDescriptionVector& remoteMediaDescriptions = internalRemoteDescription()->configuration()->mediaDescriptions();
+    unsigned mdescIndex = rtcCandidate.sdpMLineIndex();
+
+    if (mdescIndex >= remoteMediaDescriptions.size()) {
+        // FIXME: Error type?
+        promise.reject(DOMError::create("InvalidSdpMlineIndex (sdpMLineIndex out of range"));
+        return;
+    }
+
+    PeerMediaDescription& mdesc = *remoteMediaDescriptions[mdescIndex];
+    mdesc.addIceCandidate(candidate.copyRef());
+
+    m_mediaEndpoint->addRemoteCandidate(*candidate, mdescIndex, mdesc.iceUfrag(), mdesc.icePassword());
+
+    promise.resolve(nullptr);
 }
 
 void MediaEndpointPeerConnection::getStats(MediaStreamTrack*, PeerConnection::StatsPromise&& promise)
 {
-    notImplemented();
+    promise.reject(DOMError::create("Not implemented"));
+}
+
+void MediaEndpointPeerConnection::replaceTrack(RTCRtpSender& sender, MediaStreamTrack& withTrack, PeerConnection::VoidPromise&& promise)
+{
+    RefPtr<RTCRtpSender> protectedSender = &sender;
+    RefPtr<MediaStreamTrack> protectedTrack = &withTrack;
+    RefPtr<WrappedVoidPromise> wrappedPromise = WrappedVoidPromise::create(WTF::move(promise));
+
+    runTask([this, protectedSender, protectedTrack, wrappedPromise]() {
+        replaceTrackTask(*protectedSender, *protectedTrack, wrappedPromise->promise());
+    });
+}
+
+void MediaEndpointPeerConnection::replaceTrackTask(RTCRtpSender& sender, MediaStreamTrack& withTrack, PeerConnection::VoidPromise& promise)
+{
+    if (!internalRemoteDescription())
+        return;
+
+    SessionDescription* localDescription = internalLocalDescription();
+    if (!localDescription)
+        return;
+
+    const MediaDescriptionVector& mediaDescriptions = localDescription->configuration()->mediaDescriptions();
+    size_t mdescIndex = indexOfMediaDescriptionWithTrackId(mediaDescriptions, sender.trackId());
+    if (mdescIndex == notFound)
+        return;
 
-    promise.reject(DOMError::create("NotSupportedError"));
+    m_mediaEndpoint->replaceSendSource(*withTrack.source(), mdescIndex);
+
+    promise.resolve(nullptr);
 }
 
 void MediaEndpointPeerConnection::stop()
 {
-    notImplemented();
+    m_mediaEndpoint->stop();
 }
 
 void MediaEndpointPeerConnection::markAsNeedingNegotiation()
 {
-    notImplemented();
+    if (m_negotiationNeeded)
+        return;
+
+    m_negotiationNeeded = true;
+
+    if (m_client->internalSignalingState() == SignalingState::Stable)
+        m_client->scheduleNegotiationNeededEvent();
+}
+
+bool MediaEndpointPeerConnection::localDescriptionTypeValidForState(SessionDescription::Type type) const
+{
+    switch (m_client->internalSignalingState()) {
+    case SignalingState::Stable:
+        return type == SessionDescription::Type::Offer;
+    case SignalingState::HaveLocalOffer:
+        return type == SessionDescription::Type::Offer;
+    case SignalingState::HaveRemoteOffer:
+        return type == SessionDescription::Type::Answer || type == SessionDescription::Type::Pranswer;
+    case SignalingState::HaveLocalPrAnswer:
+        return type == SessionDescription::Type::Answer || type == SessionDescription::Type::Pranswer;
+    default:
+        return false;
+    };
+
+    ASSERT_NOT_REACHED();
+    return false;
+}
+
+bool MediaEndpointPeerConnection::remoteDescriptionTypeValidForState(SessionDescription::Type type) const
+{
+    switch (m_client->internalSignalingState()) {
+    case SignalingState::Stable:
+        return type == SessionDescription::Type::Offer;
+    case SignalingState::HaveLocalOffer:
+        return type == SessionDescription::Type::Answer || type == SessionDescription::Type::Pranswer;
+    case SignalingState::HaveRemoteOffer:
+        return type == SessionDescription::Type::Offer;
+    case SignalingState::HaveRemotePrAnswer:
+        return type == SessionDescription::Type::Answer || type == SessionDescription::Type::Pranswer;
+    default:
+        return false;
+    };
+
+    ASSERT_NOT_REACHED();
+    return false;
+}
+
+SessionDescription::Type MediaEndpointPeerConnection::parseDescriptionType(const String& typeName) const
+{
+    if (typeName == "offer")
+        return SessionDescription::Type::Offer;
+    if (typeName == "pranswer")
+        return SessionDescription::Type::Pranswer;
+
+    ASSERT(typeName == "answer");
+    return SessionDescription::Type::Answer;
+}
+
+static String descriptionTypeToString(SessionDescription::Type type)
+{
+    switch (type) {
+    case SessionDescription::Type::Offer:
+        return ASCIILiteral("offer");
+    case SessionDescription::Type::Pranswer:
+        return ASCIILiteral("pranswer");
+    case SessionDescription::Type::Answer:
+        return ASCIILiteral("answer");
+    case SessionDescription::Type::Rollback:
+        return ASCIILiteral("rollback");
+    }
+
+    ASSERT_NOT_REACHED();
+    return emptyString();
+}
+
+SessionDescription* MediaEndpointPeerConnection::internalLocalDescription() const
+{
+    return m_pendingLocalDescription ? m_pendingLocalDescription.get() : m_currentLocalDescription.get();
+}
+
+SessionDescription* MediaEndpointPeerConnection::internalRemoteDescription() const
+{
+    return m_pendingRemoteDescription ? m_pendingRemoteDescription.get() : m_currentRemoteDescription.get();
+}
+
+RefPtr<RTCSessionDescription> MediaEndpointPeerConnection::createRTCSessionDescription(SessionDescription* description) const
+{
+    if (!description)
+        return nullptr;
+
+    return RTCSessionDescription::create(descriptionTypeToString(description->type()), m_sdpProcessor->generate(*description->configuration()));
+}
+
+void MediaEndpointPeerConnection::gotDtlsFingerprint(const String& fingerprint, const String& fingerprintFunction)
+{
+    ASSERT(isMainThread());
+
+    m_dtlsFingerprint = fingerprint;
+    m_dtlsFingerprintFunction = fingerprintFunction;
+
+    startRunningTasks();
+}
+
+void MediaEndpointPeerConnection::gotIceCandidate(unsigned mdescIndex, RefPtr<IceCandidate>&& candidate)
+{
+    ASSERT(isMainThread());
+
+    PeerMediaDescription& mdesc = *internalLocalDescription()->configuration()->mediaDescriptions()[mdescIndex];
+    mdesc.addIceCandidate(candidate.copyRef());
+
+    // FIXME: should we still do this?
+    if (!candidate->address().contains(':')) { // not IPv6
+        if (candidate->componentId() == 1) { // RTP
+            if (mdesc.address().isEmpty() || mdesc.address() == "0.0.0.0") {
+                mdesc.setAddress(candidate->address());
+                mdesc.setPort(candidate->port());
+            }
+        } else { // RTCP
+            if (mdesc.rtcpAddress().isEmpty() || !mdesc.rtcpPort()) {
+                mdesc.setRtcpAddress(candidate->address());
+                mdesc.setRtcpPort(candidate->port());
+            }
+        }
+    }
+
+    String candidateLine = m_sdpProcessor->generateCandidateLine(*candidate);
+    RefPtr<RTCIceCandidate> iceCandidate = RTCIceCandidate::create(candidateLine, "", mdescIndex);
+
+    m_client->fireEvent(RTCIceCandidateEvent::create(false, false, WTF::move(iceCandidate)));
+}
+
+void MediaEndpointPeerConnection::doneGatheringCandidates(unsigned mdescIndex)
+{
+    ASSERT(isMainThread());
+
+    const MediaDescriptionVector& mediaDescriptions = internalLocalDescription()->configuration()->mediaDescriptions();
+    mediaDescriptions[mdescIndex]->setIceCandidateGatheringDone(true);
+
+    for (auto& mdesc : mediaDescriptions) {
+        if (!mdesc->iceCandidateGatheringDone())
+            return;
+    }
+
+    m_client->fireEvent(RTCIceCandidateEvent::create(false, false, nullptr));
+}
+
+void MediaEndpointPeerConnection::gotRemoteSource(unsigned mdescIndex, RefPtr<RealtimeMediaSource>&& source)
+{
+    ASSERT(isMainThread());
+
+    if (m_client->internalSignalingState() == SignalingState::Closed)
+        return;
+
+    const MediaDescriptionVector& remoteMediaDescriptions = internalRemoteDescription()->configuration()->mediaDescriptions();
+
+    if (mdescIndex >= remoteMediaDescriptions.size()) {
+        printf("Warning: No remote configuration for incoming source.\n");
+        return;
+    }
+
+    PeerMediaDescription& mediaDescription = *remoteMediaDescriptions[mdescIndex];
+    String trackId = mediaDescription.mediaStreamTrackId();
+
+    if (trackId.isEmpty()) {
+        // Non WebRTC media description (e.g. legacy)
+        trackId = createCanonicalUUIDString();
+    }
+
+    // FIXME: track should be set to muted (not supported yet)
+    // FIXME: MediaStream handling not implemented
+
+    RefPtr<MediaStreamTrackPrivate> trackPrivate = MediaStreamTrackPrivate::create(WTF::move(source), trackId);
+    RefPtr<MediaStreamTrack> track = MediaStreamTrack::create(*m_client->scriptExecutionContext(), *trackPrivate);
+    RefPtr<RTCRtpReceiver> receiver = RTCRtpReceiver::create(track.copyRef());
+
+    m_client->addReceiver(*receiver);
+    m_client->fireEvent(RTCTrackEvent::create(eventNames().trackEvent, false, false, WTF::move(receiver), WTF::move(track)));
 }
 
 } // namespace WebCore
diff --git a/Source/WebCore/Modules/mediastream/MediaEndpointPeerConnection.h b/Source/WebCore/Modules/mediastream/MediaEndpointPeerConnection.h
index 40ce632..ed1c7ff 100644
--- a/Source/WebCore/Modules/mediastream/MediaEndpointPeerConnection.h
+++ b/Source/WebCore/Modules/mediastream/MediaEndpointPeerConnection.h
@@ -33,18 +33,25 @@
 
 #if ENABLE(MEDIA_STREAM)
 
-#include "NotImplemented.h"
+#include "MediaEndpoint.h"
+#include "MediaEndpointConfiguration.h"
 #include "PeerConnectionBackend.h"
-#include "RTCSessionDescription.h"
+#include "SessionDescription.h"
 #include <wtf/RefPtr.h>
+#include <wtf/RefCounted.h>
 
 namespace WebCore {
 
 class MediaStreamTrack;
+class SDPProcessor;
 
-class MediaEndpointPeerConnection : public PeerConnectionBackend {
+typedef Vector<RefPtr<PeerMediaDescription>> MediaDescriptionVector;
+typedef Vector<RefPtr<RTCRtpSender>> RtpSenderVector;
+
+class MediaEndpointPeerConnection : public PeerConnectionBackend, public MediaEndpointClient {
 public:
     MediaEndpointPeerConnection(PeerConnectionBackendClient*);
+    ~MediaEndpointPeerConnection();
 
     void createOffer(RTCOfferOptions&, PeerConnection::SessionDescriptionPromise&&) override;
     void createAnswer(RTCAnswerOptions&, PeerConnection::SessionDescriptionPromise&&) override;
@@ -64,11 +71,68 @@ class MediaEndpointPeerConnection : public PeerConnectionBackend {
 
     void getStats(MediaStreamTrack*, PeerConnection::StatsPromise&&) override;
 
+    void replaceTrack(RTCRtpSender&, MediaStreamTrack&, PeerConnection::VoidPromise&&) override;
+
     void stop() override;
 
-    bool isNegotiationNeeded() const override { return false; };
-    void markAsNeedingNegotiation() override;
-    void clearNegotiationNeededState() override { notImplemented(); };
+    bool isNegotiationNeeded() const override { return m_negotiationNeeded; };
+    void markAsNeedingNegotiation();
+    void clearNegotiationNeededState() override { m_negotiationNeeded = false; };
+
+private:
+    void runTask(std::function<void ()>);
+    void startRunningTasks();
+
+    void createOfferTask(RTCOfferOptions&, PeerConnection::SessionDescriptionPromise&);
+    void createAnswerTask(RTCAnswerOptions&, PeerConnection::SessionDescriptionPromise&);
+
+    void setLocalDescriptionTask(RTCSessionDescription&, PeerConnection::VoidPromise&);
+    void setRemoteDescriptionTask(RTCSessionDescription&, PeerConnection::VoidPromise&);
+
+    void addIceCandidateTask(RTCIceCandidate&, PeerConnection::VoidPromise&);
+
+    void replaceTrackTask(RTCRtpSender&, MediaStreamTrack&, PeerConnection::VoidPromise&);
+
+    bool localDescriptionTypeValidForState(SessionDescription::Type) const;
+    bool remoteDescriptionTypeValidForState(SessionDescription::Type) const;
+    SessionDescription::Type parseDescriptionType(const String& typeName) const;
+
+    SessionDescription* internalLocalDescription() const;
+    SessionDescription* internalRemoteDescription() const;
+    RefPtr<RTCSessionDescription> createRTCSessionDescription(SessionDescription*) const;
+
+    // MediaEndpointClient
+    virtual void gotDtlsFingerprint(const String& fingerprint, const String& fingerprintFunction) override;
+    virtual void gotIceCandidate(unsigned mdescIndex, RefPtr<IceCandidate>&&) override;
+    virtual void doneGatheringCandidates(unsigned mdescIndex) override;
+    virtual void gotRemoteSource(unsigned mdescIndex, RefPtr<RealtimeMediaSource>&&) override;
+
+    PeerConnectionBackendClient* m_client;
+    std::unique_ptr<MediaEndpoint> m_mediaEndpoint;
+
+    std::function<void ()> m_initialDeferredTask;
+
+    std::unique_ptr<SDPProcessor> m_sdpProcessor;
+
+    Vector<RefPtr<MediaPayload>> m_defaultAudioPayloads;
+    Vector<RefPtr<MediaPayload>> m_defaultVideoPayloads;
+
+    String m_cname;
+    String m_iceUfrag;
+    String m_icePassword;
+    String m_dtlsFingerprint;
+    String m_dtlsFingerprintFunction;
+    unsigned m_sdpSessionVersion;
+
+    RefPtr<SessionDescription> m_currentLocalDescription;
+    RefPtr<SessionDescription> m_pendingLocalDescription;
+
+    RefPtr<SessionDescription> m_currentRemoteDescription;
+    RefPtr<SessionDescription> m_pendingRemoteDescription;
+
+    RefPtr<RTCConfiguration> m_configuration;
+
+    bool m_negotiationNeeded;
 };
 
 } // namespace WebCore
diff --git a/Source/WebCore/Modules/mediastream/MediaStream.idl b/Source/WebCore/Modules/mediastream/MediaStream.idl
index 6022285..72b471d 100644
--- a/Source/WebCore/Modules/mediastream/MediaStream.idl
+++ b/Source/WebCore/Modules/mediastream/MediaStream.idl
@@ -36,6 +36,7 @@
     sequence<MediaStreamTrack> getAudioTracks();
     sequence<MediaStreamTrack> getVideoTracks();
     sequence<MediaStreamTrack> getTracks();
+
     MediaStreamTrack getTrackById(DOMString trackId);
 
     void addTrack(MediaStreamTrack track);
diff --git a/Source/WebCore/Modules/mediastream/MediaStreamEvent.cpp b/Source/WebCore/Modules/mediastream/MediaStreamEvent.cpp
deleted file mode 100644
index ed7c23e..0000000
--- a/Source/WebCore/Modules/mediastream/MediaStreamEvent.cpp
+++ /dev/null
@@ -1,88 +0,0 @@
-/*
- * Copyright (C) 2011 Google Inc. All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1.  Redistributions of source code must retain the above copyright
- *     notice, this list of conditions and the following disclaimer.
- * 2.  Redistributions in binary form must reproduce the above copyright
- *     notice, this list of conditions and the following disclaimer in the
- *     documentation and/or other materials provided with the distribution.
- *
- * THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS'' AND ANY
- * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
- * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
- * DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS BE LIABLE FOR ANY
- * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
- * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
- * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
- * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
- * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-#include "config.h"
-#include "MediaStreamEvent.h"
-
-#if ENABLE(MEDIA_STREAM)
-
-#include "EventNames.h"
-#include "MediaStream.h"
-
-namespace WebCore {
-
-MediaStreamEventInit::MediaStreamEventInit()
-    : stream(nullptr)
-{
-}
-
-Ref<MediaStreamEvent> MediaStreamEvent::create()
-{
-    return adoptRef(*new MediaStreamEvent);
-}
-
-Ref<MediaStreamEvent> MediaStreamEvent::create(const AtomicString& type, bool canBubble, bool cancelable, PassRefPtr<MediaStream> stream)
-{
-    return adoptRef(*new MediaStreamEvent(type, canBubble, cancelable, stream));
-}
-
-Ref<MediaStreamEvent> MediaStreamEvent::create(const AtomicString& type, const MediaStreamEventInit& initializer)
-{
-    return adoptRef(*new MediaStreamEvent(type, initializer));
-}
-
-MediaStreamEvent::MediaStreamEvent()
-{
-}
-
-MediaStreamEvent::MediaStreamEvent(const AtomicString& type, bool canBubble, bool cancelable, PassRefPtr<MediaStream> stream)
-    : Event(type, canBubble, cancelable)
-    , m_stream(stream)
-{
-}
-
-MediaStreamEvent::MediaStreamEvent(const AtomicString& type, const MediaStreamEventInit& initializer)
-    : Event(type, initializer)
-    , m_stream(initializer.stream)
-{
-}
-
-MediaStreamEvent::~MediaStreamEvent()
-{
-}
-
-MediaStream* MediaStreamEvent::stream() const
-{
-    return m_stream.get();
-}
-
-EventInterface MediaStreamEvent::eventInterface() const
-{
-    return MediaStreamEventInterfaceType;
-}
-
-} // namespace WebCore
-
-#endif // ENABLE(MEDIA_STREAM)
-
diff --git a/Source/WebCore/Modules/mediastream/MediaStreamEvent.h b/Source/WebCore/Modules/mediastream/MediaStreamEvent.h
deleted file mode 100644
index b61520e..0000000
--- a/Source/WebCore/Modules/mediastream/MediaStreamEvent.h
+++ /dev/null
@@ -1,66 +0,0 @@
-/*
- * Copyright (C) 2011 Google Inc. All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1.  Redistributions of source code must retain the above copyright
- *     notice, this list of conditions and the following disclaimer.
- * 2.  Redistributions in binary form must reproduce the above copyright
- *     notice, this list of conditions and the following disclaimer in the
- *     documentation and/or other materials provided with the distribution.
- *
- * THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS'' AND ANY
- * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
- * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
- * DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS BE LIABLE FOR ANY
- * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
- * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
- * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
- * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
- * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-#ifndef MediaStreamEvent_h
-#define MediaStreamEvent_h
-
-#if ENABLE(MEDIA_STREAM)
-
-#include "Event.h"
-#include "MediaStream.h"
-#include <wtf/text/AtomicString.h>
-
-namespace WebCore {
-
-struct MediaStreamEventInit : public EventInit {
-    MediaStreamEventInit();
-
-    RefPtr<MediaStream> stream;
-};
-
-class MediaStreamEvent : public Event {
-public:
-    virtual ~MediaStreamEvent();
-
-    static Ref<MediaStreamEvent> create();
-    static Ref<MediaStreamEvent> create(const AtomicString& type, bool canBubble, bool cancelable, PassRefPtr<MediaStream>);
-    static Ref<MediaStreamEvent> create(const AtomicString& type, const MediaStreamEventInit& initializer);
-
-    MediaStream* stream() const;
-
-    virtual EventInterface eventInterface() const;
-
-private:
-    MediaStreamEvent();
-    MediaStreamEvent(const AtomicString& type, bool canBubble, bool cancelable, PassRefPtr<MediaStream>);
-    MediaStreamEvent(const AtomicString& type, const MediaStreamEventInit&);
-
-    RefPtr<MediaStream> m_stream;
-};
-
-} // namespace WebCore
-
-#endif // ENABLE(MEDIA_STREAM)
-
-#endif // MediaStreamEvent_h
diff --git a/Source/WebCore/Modules/mediastream/MediaStreamEvent.idl b/Source/WebCore/Modules/mediastream/MediaStreamEvent.idl
deleted file mode 100644
index b44729c..0000000
--- a/Source/WebCore/Modules/mediastream/MediaStreamEvent.idl
+++ /dev/null
@@ -1,31 +0,0 @@
-/*
- * Copyright (C) 2011 Google Inc. All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1.  Redistributions of source code must retain the above copyright
- *     notice, this list of conditions and the following disclaimer.
- * 2.  Redistributions in binary form must reproduce the above copyright
- *     notice, this list of conditions and the following disclaimer in the
- *     documentation and/or other materials provided with the distribution.
- *
- * THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS'' AND ANY
- * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
- * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
- * DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS BE LIABLE FOR ANY
- * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
- * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
- * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
- * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
- * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-[
-    Conditional=MEDIA_STREAM,
-    ConstructorTemplate=Event
-] interface MediaStreamEvent : Event {
-   [InitializedByEventConstructor] readonly attribute MediaStream stream;
-};
-
diff --git a/Source/WebCore/Modules/mediastream/PeerConnectionBackend.h b/Source/WebCore/Modules/mediastream/PeerConnectionBackend.h
index b95bd22..42580bf 100644
--- a/Source/WebCore/Modules/mediastream/PeerConnectionBackend.h
+++ b/Source/WebCore/Modules/mediastream/PeerConnectionBackend.h
@@ -46,6 +46,7 @@ class RTCAnswerOptions;
 class RTCConfiguration;
 class RTCIceCandidate;
 class RTCOfferOptions;
+class RTCRtpReceiver;
 class RTCRtpSender;
 class RTCSessionDescription;
 class RTCStatsResponse;
@@ -62,6 +63,7 @@ class PeerConnectionBackendClient {
     virtual Vector<RefPtr<RTCRtpSender>> getSenders() const = 0;
     virtual void fireEvent(Event&) = 0;
 
+    virtual void addReceiver(RTCRtpReceiver&) = 0;
     virtual void setSignalingState(PeerConnectionStates::SignalingState) = 0;
     virtual void updateIceGatheringState(PeerConnectionStates::IceGatheringState) = 0;
     virtual void updateIceConnectionState(PeerConnectionStates::IceConnectionState) = 0;
@@ -101,6 +103,8 @@ class PeerConnectionBackend {
 
     virtual void getStats(MediaStreamTrack*, PeerConnection::StatsPromise&&) = 0;
 
+    virtual void replaceTrack(RTCRtpSender&, MediaStreamTrack&, PeerConnection::VoidPromise&&) = 0;
+
     virtual void stop() = 0;
 
     virtual bool isNegotiationNeeded() const = 0;
diff --git a/Source/WebCore/Modules/mediastream/RTCPeerConnection.cpp b/Source/WebCore/Modules/mediastream/RTCPeerConnection.cpp
index 0352b01..b4f7ec8 100644
--- a/Source/WebCore/Modules/mediastream/RTCPeerConnection.cpp
+++ b/Source/WebCore/Modules/mediastream/RTCPeerConnection.cpp
@@ -49,8 +49,6 @@
 #include "RTCIceCandidate.h"
 #include "RTCIceCandidateEvent.h"
 #include "RTCOfferAnswerOptions.h"
-#include "RTCRtpReceiver.h"
-#include "RTCRtpSender.h"
 #include "RTCSessionDescription.h"
 #include "RTCTrackEvent.h"
 #include <wtf/MainThread.h>
@@ -81,7 +79,6 @@ RTCPeerConnection::RTCPeerConnection(ScriptExecutionContext& context, RefPtr<RTC
     , m_iceGatheringState(IceGatheringState::New)
     , m_iceConnectionState(IceConnectionState::New)
     , m_configuration(WTF::move(configuration))
-    , m_stopped(false)
 {
     Document& document = downcast<Document>(context);
 
@@ -104,24 +101,6 @@ RTCPeerConnection::~RTCPeerConnection()
     stop();
 }
 
-Vector<RefPtr<RTCRtpSender>> RTCPeerConnection::getSenders() const
-{
-    Vector<RefPtr<RTCRtpSender>> senders;
-    senders.reserveCapacity(m_senderSet.size());
-    copyValuesToVector(m_senderSet, senders);
-
-    return senders;
-}
-
-Vector<RefPtr<RTCRtpReceiver>> RTCPeerConnection::getReceivers() const
-{
-    Vector<RefPtr<RTCRtpReceiver>> receivers;
-    receivers.reserveCapacity(m_receiverSet.size());
-    copyValuesToVector(m_receiverSet, receivers);
-
-    return receivers;
-}
-
 RefPtr<RTCRtpSender> RTCPeerConnection::addTrack(RefPtr<MediaStreamTrack>&& track, Vector<MediaStream*> streams, ExceptionCode& ec)
 {
     if (!track) {
@@ -140,15 +119,21 @@ RefPtr<RTCRtpSender> RTCPeerConnection::addTrack(RefPtr<MediaStreamTrack>&& trac
         return nullptr;
     }
 
-    if (m_senderSet.contains(track->id())) {
-        // FIXME: Spec says InvalidParameter
-        ec = INVALID_MODIFICATION_ERR;
-        return nullptr;
+    for (auto& sender : m_senderSet) {
+        if (sender->trackId() == track->id()) {
+            // FIXME: Spec says InvalidParameter
+            ec = INVALID_MODIFICATION_ERR;
+            return nullptr;
+        }
     }
 
+    Vector<String> mediaStreamIds;
+    for (auto stream : streams)
+        mediaStreamIds.append(stream->id());
+
     const String& trackId = track->id();
-    RefPtr<RTCRtpSender> sender = RTCRtpSender::create(WTF::move(track), streams[0]->id());
-    m_senderSet.add(trackId, sender);
+    RefPtr<RTCRtpSender> sender = RTCRtpSender::create(WTF::move(track), WTF::move(mediaStreamIds), *this);
+    m_senderSet.append(sender);
 
     m_backend->markAsNeedingNegotiation();
 
@@ -167,9 +152,11 @@ void RTCPeerConnection::removeTrack(RTCRtpSender* sender, ExceptionCode& ec)
         return;
     }
 
-    if (!m_senderSet.remove(sender->track()->id()))
+    if (!m_senderSet.contains(sender))
         return;
 
+    sender->invalidateClient();
+
     m_backend->markAsNeedingNegotiation();
 }
 
@@ -380,17 +367,18 @@ void RTCPeerConnection::close()
     if (m_signalingState == SignalingState::Closed)
         return;
 
+    m_backend->stop();
+
+    m_iceConnectionState = IceConnectionState::Closed;
     m_signalingState = SignalingState::Closed;
+
+    for (auto& sender : m_senderSet)
+        sender->invalidateClient();
 }
 
 void RTCPeerConnection::stop()
 {
-    if (m_stopped)
-        return;
-
-    m_stopped = true;
-    m_iceConnectionState = IceConnectionState::Closed;
-    m_signalingState = SignalingState::Closed;
+    close();
 }
 
 const char* RTCPeerConnection::activeDOMObjectName() const
@@ -404,6 +392,11 @@ bool RTCPeerConnection::canSuspendForDocumentSuspension() const
     return false;
 }
 
+void RTCPeerConnection::addReceiver(RTCRtpReceiver& receiver)
+{
+    m_receiverSet.append(&receiver);
+}
+
 void RTCPeerConnection::setSignalingState(SignalingState newState)
 {
     m_signalingState = newState;
@@ -442,6 +435,11 @@ void RTCPeerConnection::fireEvent(Event& event)
     dispatchEvent(event);
 }
 
+void RTCPeerConnection::replaceTrack(RTCRtpSender& sender, MediaStreamTrack& withTrack, PeerConnection::VoidPromise&& promise)
+{
+    m_backend->replaceTrack(sender, withTrack, WTF::move(promise));
+}
+
 } // namespace WebCore
 
 #endif // ENABLE(MEDIA_STREAM)
diff --git a/Source/WebCore/Modules/mediastream/RTCPeerConnection.h b/Source/WebCore/Modules/mediastream/RTCPeerConnection.h
index a4f9025..e30e7ff 100644
--- a/Source/WebCore/Modules/mediastream/RTCPeerConnection.h
+++ b/Source/WebCore/Modules/mediastream/RTCPeerConnection.h
@@ -41,6 +41,8 @@
 // FIXME: Workaround for bindings bug http://webkit.org/b/150121
 #include "JSMediaStream.h"
 #include "PeerConnectionBackend.h"
+#include "RTCRtpReceiver.h"
+#include "RTCRtpSender.h"
 #include "ScriptWrappable.h"
 #include <wtf/HashMap.h>
 #include <wtf/RefCounted.h>
@@ -54,18 +56,16 @@ class RTCConfiguration;
 class RTCDataChannel;
 class RTCIceCandidate;
 class RTCPeerConnectionErrorCallback;
-class RTCRtpReceiver;
-class RTCRtpSender;
 class RTCSessionDescription;
 class RTCStatsCallback;
 
-class RTCPeerConnection final : public RefCounted<RTCPeerConnection>, public ScriptWrappable, public PeerConnectionBackendClient, public EventTargetWithInlineData, public ActiveDOMObject {
+class RTCPeerConnection final : public RefCounted<RTCPeerConnection>, public ScriptWrappable, public PeerConnectionBackendClient, public RTCRtpSenderClient, public EventTargetWithInlineData, public ActiveDOMObject {
 public:
     static RefPtr<RTCPeerConnection> create(ScriptExecutionContext&, const Dictionary& rtcConfiguration, ExceptionCode&);
     ~RTCPeerConnection();
 
-    Vector<RefPtr<RTCRtpSender>> getSenders() const override;
-    Vector<RefPtr<RTCRtpReceiver>> getReceivers() const;
+    Vector<RefPtr<RTCRtpSender>> getSenders() const override { return m_senderSet; }
+    Vector<RefPtr<RTCRtpReceiver>> getReceivers() const { return m_receiverSet; }
 
     RefPtr<RTCRtpSender> addTrack(RefPtr<MediaStreamTrack>&&, Vector<MediaStream*>, ExceptionCode&);
     void removeTrack(RTCRtpSender*, ExceptionCode&);
@@ -120,6 +120,7 @@ class RTCPeerConnection final : public RefCounted<RTCPeerConnection>, public Scr
     bool canSuspendForDocumentSuspension() const override;
 
     // PeerConnectionBackendClient
+    void addReceiver(RTCRtpReceiver&) override;
     void setSignalingState(PeerConnectionStates::SignalingState) override;
     void updateIceGatheringState(PeerConnectionStates::IceGatheringState) override;
     void updateIceConnectionState(PeerConnectionStates::IceConnectionState) override;
@@ -131,20 +132,21 @@ class RTCPeerConnection final : public RefCounted<RTCPeerConnection>, public Scr
     PeerConnectionStates::IceGatheringState internalIceGatheringState() const override { return m_iceGatheringState; }
     PeerConnectionStates::IceConnectionState internalIceConnectionState() const override { return m_iceConnectionState; }
 
+    // RTCRtpSenderClient
+    void replaceTrack(RTCRtpSender&, MediaStreamTrack&, PeerConnection::VoidPromise&&) override;
+
     PeerConnectionStates::SignalingState m_signalingState;
     PeerConnectionStates::IceGatheringState m_iceGatheringState;
     PeerConnectionStates::IceConnectionState m_iceConnectionState;
 
-    HashMap<String, RefPtr<RTCRtpSender>> m_senderSet;
-    HashMap<String, RefPtr<RTCRtpReceiver>> m_receiverSet;
+    Vector<RefPtr<RTCRtpSender>> m_senderSet;
+    Vector<RefPtr<RTCRtpReceiver>> m_receiverSet;
 
     Vector<RefPtr<RTCDataChannel>> m_dataChannels;
 
     std::unique_ptr<PeerConnectionBackend> m_backend;
 
     RefPtr<RTCConfiguration> m_configuration;
-
-    bool m_stopped;
 };
 
 } // namespace WebCore
diff --git a/Source/WebCore/Modules/mediastream/RTCRtpSender.cpp b/Source/WebCore/Modules/mediastream/RTCRtpSender.cpp
index 8813a53..552d304 100644
--- a/Source/WebCore/Modules/mediastream/RTCRtpSender.cpp
+++ b/Source/WebCore/Modules/mediastream/RTCRtpSender.cpp
@@ -33,14 +33,42 @@
 
 #if ENABLE(MEDIA_STREAM)
 
+#include "ExceptionCode.h"
+#include "DOMError.h"
+#include "JSDOMError.h"
+
 namespace WebCore {
 
-RTCRtpSender::RTCRtpSender(RefPtr<MediaStreamTrack>&& track, const String& mediaStreamId)
+RTCRtpSender::RTCRtpSender(RefPtr<MediaStreamTrack>&& track, Vector<String>&& mediaStreamIds, RTCRtpSenderClient& client)
     : RTCRtpSenderReceiverBase(WTF::move(track))
-    , m_mediaStreamId(mediaStreamId)
+    , m_mediaStreamIds(WTF::move(mediaStreamIds))
+    , m_client(&client)
+{
+    // The original track id is always used in negotiation even if the track is replaced.
+    m_trackId = m_track->id();
+}
+
+void RTCRtpSender::replaceTrack(MediaStreamTrack* withTrack, PeerConnection::VoidPromise&& promise, ExceptionCode& ec)
 {
+    if (!withTrack) {
+        ec = TypeError;
+        return;
+    }
+
+    if (!m_client) {
+        promise.reject(DOMError::create("InvalidStateError"));
+        return;
+    }
+
+    if (m_track->kind() != withTrack->kind()) {
+        promise.reject(DOMError::create("TypeError"));
+        return;
+    }
+
+    m_client->replaceTrack(*this, *withTrack, WTF::move(promise));
 }
 
+
 } // namespace WebCore
 
 #endif // ENABLE(MEDIA_STREAM)
diff --git a/Source/WebCore/Modules/mediastream/RTCRtpSender.h b/Source/WebCore/Modules/mediastream/RTCRtpSender.h
index 6885ac6..89100e2 100644
--- a/Source/WebCore/Modules/mediastream/RTCRtpSender.h
+++ b/Source/WebCore/Modules/mediastream/RTCRtpSender.h
@@ -33,24 +33,39 @@
 
 #if ENABLE(MEDIA_STREAM)
 
+#include "PeerConnectionBackend.h"
 #include "RTCRtpSenderReceiverBase.h"
 #include <wtf/text/WTFString.h>
 
 namespace WebCore {
 
+class RTCRtpSenderClient {
+public:
+    virtual void replaceTrack(RTCRtpSender&, MediaStreamTrack&, PeerConnection::VoidPromise&&) = 0;
+
+    virtual ~RTCRtpSenderClient() { }
+};
+
 class RTCRtpSender : public RTCRtpSenderReceiverBase {
 public:
-    static Ref<RTCRtpSender> create(RefPtr<MediaStreamTrack>&& track, const String& mediaStreamId)
+    static Ref<RTCRtpSender> create(RefPtr<MediaStreamTrack>&& track, Vector<String>&& mediaStreamIds, RTCRtpSenderClient& client)
     {
-        return adoptRef(*new RTCRtpSender(WTF::move(track), mediaStreamId));
+        return adoptRef(*new RTCRtpSender(WTF::move(track), WTF::move(mediaStreamIds), client));
     }
 
-    const String& mediaStreamId() const { return m_mediaStreamId; }
+    const String& trackId() { return m_trackId; }
+    const Vector<String>& mediaStreamIds() const { return m_mediaStreamIds; }
+
+    void invalidateClient() { m_client = nullptr; }
+
+    void replaceTrack(MediaStreamTrack*, PeerConnection::VoidPromise&&, ExceptionCode&);
 
 private:
-    RTCRtpSender(RefPtr<MediaStreamTrack>&&, const String& mediaStreamId);
+    RTCRtpSender(RefPtr<MediaStreamTrack>&&, Vector<String>&& mediaStreamIds, RTCRtpSenderClient&);
 
-    String m_mediaStreamId;
+    String m_trackId;
+    Vector<String> m_mediaStreamIds;
+    RTCRtpSenderClient* m_client;
 };
 
 } // namespace WebCore
diff --git a/Source/WebCore/Modules/mediastream/RTCRtpSender.idl b/Source/WebCore/Modules/mediastream/RTCRtpSender.idl
index 8cb2755..30272df 100644
--- a/Source/WebCore/Modules/mediastream/RTCRtpSender.idl
+++ b/Source/WebCore/Modules/mediastream/RTCRtpSender.idl
@@ -32,4 +32,6 @@
     Conditional=MEDIA_STREAM
 ] interface RTCRtpSender {
     readonly attribute MediaStreamTrack track;
+
+    [StrictTypeChecking, RaisesException] Promise replaceTrack(MediaStreamTrack withTrack);
 };
diff --git a/Source/WebCore/Modules/mediastream/SDPProcessor.cpp b/Source/WebCore/Modules/mediastream/SDPProcessor.cpp
new file mode 100644
index 0000000..831372d
--- /dev/null
+++ b/Source/WebCore/Modules/mediastream/SDPProcessor.cpp
@@ -0,0 +1,452 @@
+/*
+ * Copyright (C) 2015 Ericsson AB. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer
+ *    in the documentation and/or other materials provided with the
+ *    distribution.
+ * 3. Neither the name of Ericsson nor the names of its contributors
+ *    may be used to endorse or promote products derived from this
+ *    software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include "config.h"
+
+#if ENABLE(MEDIA_STREAM)
+#include "SDPProcessor.h"
+
+#include "Document.h"
+#include "Frame.h"
+#include "SDPProcessorScriptResource.h"
+#include "ScriptController.h"
+#include "ScriptGlobalObject.h"
+#include "ScriptSourceCode.h"
+#include "inspector/InspectorValues.h"
+#include <bindings/ScriptObject.h>
+
+using namespace Inspector;
+
+namespace WebCore {
+
+SDPProcessor::SDPProcessor(ScriptExecutionContext* context)
+    : ContextDestructionObserver(context)
+{
+}
+
+// Note that MediaEndpointConfiguration is a "flatter" structure that the JSON representation. For
+// example, the JSON representation has an "ice" object which collects a set of properties under a
+// namespace. MediaEndpointConfiguration has "ice"-prefixes on the corresponding properties.
+
+static RefPtr<InspectorObject> createCandidateObject(const IceCandidate& candidate)
+{
+    RefPtr<InspectorObject> candidateObject = InspectorObject::create();
+
+    candidateObject->setString(ASCIILiteral("type"), candidate.type());
+    candidateObject->setString(ASCIILiteral("foundation"), candidate.foundation());
+    candidateObject->setInteger(ASCIILiteral("componentId"), candidate.componentId());
+    candidateObject->setString(ASCIILiteral("transport"), candidate.transport());
+    candidateObject->setInteger(ASCIILiteral("priority"), candidate.priority());
+    candidateObject->setString(ASCIILiteral("address"), candidate.address());
+    candidateObject->setInteger(ASCIILiteral("port"), candidate.port());
+    if (!candidate.tcpType().isEmpty())
+        candidateObject->setString(ASCIILiteral("tcpType"), candidate.tcpType());
+    if (candidate.type().upper() != "HOST") {
+        candidateObject->setString(ASCIILiteral("relatedAddress"), candidate.relatedAddress());
+        candidateObject->setInteger(ASCIILiteral("relatedPort"), candidate.relatedPort());
+    }
+
+    return candidateObject;
+}
+
+static RefPtr<IceCandidate> createCandidate(const InspectorObject& candidateObject)
+{
+    RefPtr<IceCandidate> candidate = IceCandidate::create();
+    String stringValue;
+    unsigned intValue;
+
+    if (candidateObject.getString(ASCIILiteral("type"), stringValue))
+        candidate->setType(stringValue);
+
+    if (candidateObject.getString(ASCIILiteral("foundation"), stringValue))
+        candidate->setFoundation(stringValue);
+
+    if (candidateObject.getInteger(ASCIILiteral("componentId"), intValue))
+        candidate->setComponentId(intValue);
+
+    if (candidateObject.getString(ASCIILiteral("transport"), stringValue))
+        candidate->setTransport(stringValue);
+
+    if (candidateObject.getInteger(ASCIILiteral("priority"), intValue))
+        candidate->setPriority(intValue);
+
+    if (candidateObject.getString(ASCIILiteral("address"), stringValue))
+        candidate->setAddress(stringValue);
+
+    if (candidateObject.getInteger(ASCIILiteral("port"), intValue))
+        candidate->setPort(intValue);
+
+    if (candidateObject.getString(ASCIILiteral("tcpType"), stringValue))
+        candidate->setTcpType(stringValue);
+
+    if (candidateObject.getString(ASCIILiteral("relatedAddress"), stringValue))
+        candidate->setRelatedAddress(stringValue);
+
+    if (candidateObject.getInteger(ASCIILiteral("relatedPort"), intValue))
+        candidate->setRelatedPort(intValue);
+
+    return candidate;
+}
+
+static RefPtr<MediaEndpointConfiguration> configurationFromJSON(const String& json)
+{
+    RefPtr<InspectorValue> value;
+    if (!InspectorValue::parseJSON(json, value))
+        return nullptr;
+
+    RefPtr<InspectorObject> object;
+    if (!value->asObject(object))
+        return nullptr;
+
+    RefPtr<MediaEndpointConfiguration> configuration = MediaEndpointConfiguration::create();
+
+    String stringValue;
+    unsigned intValue;
+    unsigned long longValue;
+    bool boolValue;
+
+    RefPtr<InspectorObject> originatorObject = InspectorObject::create();
+    if (object->getObject(ASCIILiteral("originator"), originatorObject)) {
+        if (originatorObject->getInteger(ASCIILiteral("sessionId"), longValue))
+            configuration->setSessionId(longValue);
+        if (originatorObject->getInteger(ASCIILiteral("sessionVersion"), intValue))
+            configuration->setSessionVersion(intValue);
+    }
+
+    RefPtr<InspectorArray> mediaDescriptionsArray = InspectorArray::create();
+    object->getArray(ASCIILiteral("mediaDescriptions"), mediaDescriptionsArray);
+
+    for (unsigned i = 0; i < mediaDescriptionsArray->length(); ++i) {
+        RefPtr<InspectorObject> mdescObject = InspectorObject::create();
+        mediaDescriptionsArray->get(i)->asObject(mdescObject);
+
+        RefPtr<PeerMediaDescription> mdesc = PeerMediaDescription::create();
+
+        if (mdescObject->getString(ASCIILiteral("type"), stringValue))
+            mdesc->setType(stringValue);
+
+        if (mdescObject->getInteger(ASCIILiteral("port"), intValue))
+            mdesc->setPort(intValue);
+
+        if (mdescObject->getString(ASCIILiteral("address"), stringValue))
+            mdesc->setAddress(stringValue);
+
+        if (mdescObject->getString(ASCIILiteral("mode"), stringValue))
+            mdesc->setMode(stringValue);
+
+        RefPtr<InspectorArray> payloadsArray = InspectorArray::create();
+        mdescObject->getArray(ASCIILiteral("payloads"), payloadsArray);
+
+        for (unsigned j = 0; j < payloadsArray->length(); ++j) {
+            RefPtr<InspectorObject> payloadsObject = InspectorObject::create();
+            payloadsArray->get(j)->asObject(payloadsObject);
+
+            RefPtr<MediaPayload> payload = MediaPayload::create();
+
+            if (payloadsObject->getInteger(ASCIILiteral("type"), intValue))
+                payload->setType(intValue);
+
+            if (payloadsObject->getString(ASCIILiteral("encodingName"), stringValue))
+                payload->setEncodingName(stringValue);
+
+            if (payloadsObject->getInteger(ASCIILiteral("clockRate"), intValue))
+                payload->setClockRate(intValue);
+
+            if (payloadsObject->getInteger(ASCIILiteral("channels"), intValue))
+                payload->setChannels(intValue);
+
+            if (payloadsObject->getBoolean(ASCIILiteral("ccmfir"), boolValue))
+                payload->setCcmfir(boolValue);
+
+            if (payloadsObject->getBoolean(ASCIILiteral("nackpli"), boolValue))
+                payload->setNackpli(boolValue);
+
+            if (payloadsObject->getBoolean(ASCIILiteral("nack"), boolValue))
+                payload->setNack(boolValue);
+
+            RefPtr<InspectorObject> parametersObject = InspectorObject::create();
+            if (payloadsObject->getObject(ASCIILiteral("parameters"), parametersObject)) {
+                if (parametersObject->getInteger(ASCIILiteral("packetizationMode"), intValue))
+                    payload->addParameter("packetizationMode", intValue);
+
+                if (parametersObject->getInteger(ASCIILiteral("apt"), intValue))
+                    payload->addParameter("apt", intValue);
+
+                if (parametersObject->getInteger(ASCIILiteral("rtxTime"), intValue))
+                    payload->addParameter("rtxTime", intValue);
+            }
+
+            mdesc->addPayload(WTF::move(payload));
+        }
+
+        RefPtr<InspectorObject> rtcpObject = InspectorObject::create();
+        if (mdescObject->getObject(ASCIILiteral("rtcp"), rtcpObject)) {
+            if (rtcpObject->getBoolean(ASCIILiteral("mux"), boolValue))
+                mdesc->setRtcpMux(boolValue);
+
+            if (rtcpObject->getString(ASCIILiteral("rtcpAddress"), stringValue))
+                mdesc->setRtcpAddress(stringValue);
+
+            if (rtcpObject->getInteger(ASCIILiteral("rtcpPort"), intValue))
+                mdesc->setRtcpPort(intValue);
+        }
+
+        if (mdescObject->getString(ASCIILiteral("mediaStreamId"), stringValue))
+            mdesc->setMediaStreamId(stringValue);
+
+        if (mdescObject->getString(ASCIILiteral("mediaStreamTrackId"), stringValue))
+            mdesc->setMediaStreamTrackId(stringValue);
+
+        RefPtr<InspectorObject> dtlsObject = InspectorObject::create();
+        if (mdescObject->getObject(ASCIILiteral("dtls"), dtlsObject)) {
+            if (dtlsObject->getString(ASCIILiteral("setup"), stringValue))
+                mdesc->setDtlsSetup(stringValue);
+
+            if (dtlsObject->getString(ASCIILiteral("fingerprintHashFunction"), stringValue))
+                mdesc->setDtlsFingerprintHashFunction(stringValue);
+
+            if (dtlsObject->getString(ASCIILiteral("fingerprint"), stringValue))
+                mdesc->setDtlsFingerprint(stringValue);
+        }
+
+        RefPtr<InspectorArray> ssrcsArray = InspectorArray::create();
+        mdescObject->getArray(ASCIILiteral("ssrcs"), ssrcsArray);
+
+        for (unsigned j = 0; j < ssrcsArray->length(); ++j) {
+            ssrcsArray->get(j)->asInteger(intValue);
+            mdesc->addSsrc(intValue);
+        }
+
+        if (mdescObject->getString(ASCIILiteral("cname"), stringValue))
+            mdesc->setCname(stringValue);
+
+        RefPtr<InspectorObject> iceObject = InspectorObject::create();
+        if (mdescObject->getObject(ASCIILiteral("ice"), iceObject)) {
+            if (iceObject->getString(ASCIILiteral("ufrag"), stringValue))
+                mdesc->setIceUfrag(stringValue);
+
+            if (iceObject->getString(ASCIILiteral("password"), stringValue))
+                mdesc->setIcePassword(stringValue);
+
+            RefPtr<InspectorArray> candidatesArray = InspectorArray::create();
+            iceObject->getArray(ASCIILiteral("candidates"), candidatesArray);
+
+            for (unsigned j = 0; j < candidatesArray->length(); ++j) {
+                RefPtr<InspectorObject> candidateObject = InspectorObject::create();
+                candidatesArray->get(j)->asObject(candidateObject);
+
+                mdesc->addIceCandidate(createCandidate(*candidateObject));
+            }
+        }
+
+        configuration->addMediaDescription(WTF::move(mdesc));
+    }
+
+    return configuration;
+}
+
+static RefPtr<IceCandidate> iceCandidateFromJSON(const String& json)
+{
+    RefPtr<InspectorValue> value;
+    if (!InspectorValue::parseJSON(json, value))
+        return nullptr;
+
+    RefPtr<InspectorObject> candidateObject;
+    if (!value->asObject(candidateObject))
+        return nullptr;
+
+    return createCandidate(*candidateObject);
+}
+
+static String configurationToJSON(const MediaEndpointConfiguration& configuration)
+{
+    RefPtr<InspectorObject> object = InspectorObject::create();
+
+    RefPtr<InspectorObject> originatorObject = InspectorObject::create();
+    originatorObject->setDouble(ASCIILiteral("sessionId"), configuration.sessionId());
+    originatorObject->setInteger(ASCIILiteral("sessionVersion"), configuration.sessionVersion());
+    object->setObject(ASCIILiteral("originator"), originatorObject);
+
+    RefPtr<InspectorArray> mediaDescriptionsArray = InspectorArray::create();
+
+    for (const RefPtr<PeerMediaDescription>& mdesc : configuration.mediaDescriptions()) {
+        RefPtr<InspectorObject> mdescObject = InspectorObject::create();
+
+        mdescObject->setString(ASCIILiteral("type"), mdesc->type());
+        mdescObject->setInteger(ASCIILiteral("port"), mdesc->port());
+        mdescObject->setString(ASCIILiteral("address"), mdesc->address());
+        mdescObject->setString(ASCIILiteral("mode"), mdesc->mode());
+
+        RefPtr<InspectorArray> payloadsArray = InspectorArray::create();
+
+        for (RefPtr<MediaPayload> payload : mdesc->payloads()) {
+            RefPtr<InspectorObject> payloadObject = InspectorObject::create();
+
+            payloadObject->setInteger(ASCIILiteral("type"), payload->type());
+            payloadObject->setString(ASCIILiteral("encodingName"), payload->encodingName());
+            payloadObject->setInteger(ASCIILiteral("clockRate"), payload->clockRate());
+            payloadObject->setInteger(ASCIILiteral("channels"), payload->channels());
+            payloadObject->setBoolean(ASCIILiteral("ccmfir"), payload->ccmfir());
+            payloadObject->setBoolean(ASCIILiteral("nackpli"), payload->nackpli());
+            payloadObject->setBoolean(ASCIILiteral("nack"), payload->nack());
+
+            if (!payload->parameters().isEmpty()) {
+                RefPtr<InspectorObject> parametersObject = InspectorObject::create();
+
+                for (auto& name : payload->parameters().keys())
+                    parametersObject->setInteger(name, payload->parameters().get(name));
+
+                payloadObject->setObject(ASCIILiteral("parameters"), parametersObject);
+            }
+
+            payloadsArray->pushObject(payloadObject);
+        }
+        mdescObject->setArray(ASCIILiteral("payloads"), payloadsArray);
+
+        RefPtr<InspectorObject> rtcpObject = InspectorObject::create();
+        rtcpObject->setBoolean(ASCIILiteral("mux"), mdesc->rtcpMux());
+        rtcpObject->setString(ASCIILiteral("address"), mdesc->rtcpAddress());
+        rtcpObject->setInteger(ASCIILiteral("port"), mdesc->rtcpPort());
+        mdescObject->setObject(ASCIILiteral("rtcp"), rtcpObject);
+
+        mdescObject->setString(ASCIILiteral("mediaStreamId"), mdesc->mediaStreamId());
+        mdescObject->setString(ASCIILiteral("mediaStreamTrackId"), mdesc->mediaStreamTrackId());
+
+        RefPtr<InspectorObject> dtlsObject = InspectorObject::create();
+        dtlsObject->setString(ASCIILiteral("setup"), mdesc->dtlsSetup());
+        dtlsObject->setString(ASCIILiteral("fingerprintHashFunction"), mdesc->dtlsFingerprintHashFunction());
+        dtlsObject->setString(ASCIILiteral("fingerprint"), mdesc->dtlsFingerprint());
+        mdescObject->setObject(ASCIILiteral("dtls"), dtlsObject);
+
+        RefPtr<InspectorArray> ssrcsArray = InspectorArray::create();
+
+        for (auto ssrc : mdesc->ssrcs())
+            ssrcsArray->pushDouble(ssrc);
+        mdescObject->setArray(ASCIILiteral("ssrcs"), ssrcsArray);
+
+        mdescObject->setString(ASCIILiteral("cname"), mdesc->cname());
+
+        RefPtr<InspectorObject> iceObject = InspectorObject::create();
+        iceObject->setString(ASCIILiteral("ufrag"), mdesc->iceUfrag());
+        iceObject->setString(ASCIILiteral("password"), mdesc->icePassword());
+
+        RefPtr<InspectorArray> candidatesArray = InspectorArray::create();
+
+        for (RefPtr<IceCandidate> candidate : mdesc->iceCandidates())
+            candidatesArray->pushObject(createCandidateObject(*candidate));
+
+        iceObject->setArray(ASCIILiteral("candidates"), candidatesArray);
+        mdescObject->setObject(ASCIILiteral("ice"), iceObject);
+
+        mediaDescriptionsArray->pushObject(mdescObject);
+    }
+    object->setArray(ASCIILiteral("mediaDescriptions"), mediaDescriptionsArray);
+
+    return object->toJSONString();
+}
+
+static String iceCandidateToJSON(const IceCandidate& candidate)
+{
+    return createCandidateObject(candidate)->toJSONString();
+}
+
+String SDPProcessor::generate(const MediaEndpointConfiguration& configuration) const
+{
+    return callScript("generate", configurationToJSON(configuration));
+}
+
+RefPtr<MediaEndpointConfiguration> SDPProcessor::parse(const String& sdp) const
+{
+    return configurationFromJSON(callScript("parse", sdp));
+}
+
+String SDPProcessor::generateCandidateLine(const IceCandidate& candidate) const
+{
+    return callScript("generateCandidateLine", iceCandidateToJSON(candidate));
+}
+
+RefPtr<IceCandidate> SDPProcessor::parseCandidateLine(const String& candidateLine) const
+{
+    return iceCandidateFromJSON(callScript("parseCandidateLine", candidateLine));
+}
+
+String SDPProcessor::callScript(const String& functionName, const String& argument) const
+{
+    if (!scriptExecutionContext())
+        return emptyString();
+
+    Document* document = downcast<Document>(scriptExecutionContext());
+    if (!document->frame())
+        return emptyString();
+
+    if (!m_isolatedWorld)
+        m_isolatedWorld = DOMWrapperWorld::create(JSDOMWindow::commonVM());
+
+    ScriptController& scriptController = document->frame()->script();
+    JSDOMGlobalObject* globalObject = JSC::jsCast<JSDOMGlobalObject*>(scriptController.globalObject(*m_isolatedWorld));
+    JSC::ExecState* exec = globalObject->globalExec();
+    JSC::JSLockHolder lock(exec);
+
+    JSC::JSValue probeFunctionValue = globalObject->get(exec, JSC::Identifier::fromString(exec, "generate"));
+    if (!probeFunctionValue.isFunction()) {
+        URL scriptURL;
+        scriptController.evaluateInWorld(ScriptSourceCode(SDPProcessorScriptResource::scriptString(), scriptURL), *m_isolatedWorld);
+        if (exec->hadException()) {
+            exec->clearException();
+            return emptyString();
+        }
+    }
+
+    JSC::JSValue functionValue = globalObject->get(exec, JSC::Identifier::fromString(exec, functionName));
+    if (!functionValue.isFunction())
+        return emptyString();
+
+    JSC::JSObject* function = functionValue.toObject(exec);
+    JSC::CallData callData;
+    JSC::CallType callType = function->methodTable()->getCallData(function, callData);
+    if (callType == JSC::CallTypeNone)
+        return emptyString();
+
+    JSC::MarkedArgumentBuffer argList;
+    argList.append(JSC::jsString(exec, argument));
+
+    JSC::JSValue result = JSC::call(exec, function, callType, callData, globalObject, argList);
+    if (exec->hadException()) {
+        printf("SDPProcessor::callScript(): %s() threw\n", functionName.ascii().data());
+        exec->clearException();
+        return emptyString();
+    }
+
+    return result.isString() ? result.getString(exec) : emptyString();
+}
+
+} // namespace WebCore
+
+#endif // ENABLE(MEDIA_STREAM)
diff --git a/Source/WebCore/Modules/mediastream/SDPProcessor.h b/Source/WebCore/Modules/mediastream/SDPProcessor.h
new file mode 100644
index 0000000..a67c3a9
--- /dev/null
+++ b/Source/WebCore/Modules/mediastream/SDPProcessor.h
@@ -0,0 +1,67 @@
+/*
+ * Copyright (C) 2015 Ericsson AB. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer
+ *    in the documentation and/or other materials provided with the
+ *    distribution.
+ * 3. Neither the name of Ericsson nor the names of its contributors
+ *    may be used to endorse or promote products derived from this
+ *    software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef SDPProcessor_h
+#define SDPProcessor_h
+
+#if ENABLE(MEDIA_STREAM)
+
+#include "ContextDestructionObserver.h"
+#include "IceCandidate.h"
+#include "MediaEndpointConfiguration.h"
+#include <wtf/RefPtr.h>
+#include <wtf/text/WTFString.h>
+
+namespace WebCore {
+
+class DOMWrapperWorld;
+class ScriptExecutionContext;
+
+class SDPProcessor : public ContextDestructionObserver {
+public:
+    SDPProcessor(ScriptExecutionContext*);
+
+    String generate(const MediaEndpointConfiguration&) const;
+    RefPtr<MediaEndpointConfiguration> parse(const String& sdp) const;
+
+    String generateCandidateLine(const IceCandidate&) const;
+    RefPtr<IceCandidate> parseCandidateLine(const String& candidateLine) const;
+
+private:
+    String callScript(const String& functionName, const String& argument) const;
+
+    mutable RefPtr<DOMWrapperWorld> m_isolatedWorld;
+};
+
+} // namespace WebCore
+
+#endif // ENABLE(MEDIA_STREAM)
+
+#endif // SDPProcessor_h
diff --git a/Source/WebCore/Modules/mediastream/SessionDescription.h b/Source/WebCore/Modules/mediastream/SessionDescription.h
new file mode 100644
index 0000000..3500a46
--- /dev/null
+++ b/Source/WebCore/Modules/mediastream/SessionDescription.h
@@ -0,0 +1,77 @@
+/*
+ * Copyright (C) 2015 Ericsson AB. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer
+ *    in the documentation and/or other materials provided with the
+ *    distribution.
+ * 3. Neither the name of Ericsson nor the names of its contributors
+ *    may be used to endorse or promote products derived from this
+ *    software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef SessionDescription_h
+#define SessionDescription_h
+
+#if ENABLE(MEDIA_STREAM)
+
+#include <wtf/RefPtr.h>
+#include <wtf/RefCounted.h>
+
+namespace WebCore {
+
+class MediaEndpointConfiguration;
+
+class SessionDescription : public RefCounted<SessionDescription> {
+public:
+    enum class Type {
+        Offer = 1,
+        Pranswer = 2,
+        Answer = 3,
+        Rollback = 4
+    };
+
+    static RefPtr<SessionDescription> create(Type type, RefPtr<MediaEndpointConfiguration>&& configuration)
+    {
+        return adoptRef(new SessionDescription(type, WTF::move(configuration)));
+    }
+    virtual ~SessionDescription() { }
+
+    Type type() const { return m_type; }
+    MediaEndpointConfiguration* configuration() const { return m_configuration.get(); }
+
+    bool isLaterThan(SessionDescription* other) { return !other || configuration()->sessionVersion() > other->configuration()->sessionVersion(); }
+
+private:
+    SessionDescription(Type type, RefPtr<MediaEndpointConfiguration>&& configuration)
+        : m_type(type)
+        , m_configuration(configuration)
+    { }
+
+    Type m_type;
+    RefPtr<MediaEndpointConfiguration> m_configuration;
+};
+
+} // namespace WebCore
+
+#endif // ENABLE(MEDIA_STREAM)
+
+#endif // SessionDescription_h
diff --git a/Source/WebCore/Modules/mediastream/sdp.js b/Source/WebCore/Modules/mediastream/sdp.js
new file mode 100644
index 0000000..f081c25
--- /dev/null
+++ b/Source/WebCore/Modules/mediastream/sdp.js
@@ -0,0 +1,550 @@
+/*
+ * Copyright (C) 2014-2015 Ericsson AB. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer
+ *    in the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+"use strict";
+
+if (typeof(SDP) == "undefined")
+    var SDP = {};
+
+(function () {
+    var regexps = {
+        "vline": "^v=([\\d]+).*$",
+        "oline": "^o=([\\w\\-@\\.]+) ([\\d]+) ([\\d]+) IN (IP[46]) ([\\d\\.a-f\\:]+).*$",
+        "sline": "^s=(.*)$",
+        "tline": "^t=([\\d]+) ([\\d]+).*$",
+        "cline": "^c=IN (IP[46]) ([\\d\\.a-f\\:]+).*$",
+        "msidsemantic": "^a=msid-semantic: *WMS .*$",
+        "mblock": "^m=(audio|video|application) ([\\d]+) ([A-Z/]+)([\\d ]*)$\\r?\\n",
+        "mode": "^a=(sendrecv|sendonly|recvonly|inactive).*$",
+        "rtpmap": "^a=rtpmap:${type} ([\\w\\-]+)/([\\d]+)/?([\\d]+)?.*$",
+        "fmtp": "^a=fmtp:${type} ([\\w\\-=;]+).*$",
+        "param": "([\\w\\-]+)=([\\w\\-]+);?",
+        "nack": "^a=rtcp-fb:${type} nack$",
+        "nackpli": "^a=rtcp-fb:${type} nack pli$",
+        "ccmfir": "^a=rtcp-fb:${type} ccm fir$",
+        "ericscream": "^a=rtcp-fb:${type} ericscream$",
+        "rtcp": "^a=rtcp:([\\d]+)( IN (IP[46]) ([\\d\\.a-f\\:]+))?.*$",
+        "rtcpmux": "^a=rtcp-mux.*$",
+        "cname": "^a=ssrc:(\\d+) cname:([\\w+/\\-@\\.\\{\\}]+).*$",
+        "msid": "^a=(ssrc:\\d+ )?msid:([\\w+/\\-=]+) +([\\w+/\\-=]+).*$",
+        "ufrag": "^a=ice-ufrag:([\\w+/]*).*$",
+        "pwd": "^a=ice-pwd:([\\w+/]*).*$",
+        "candidate": "^a=candidate:(\\d+) (\\d) (UDP|TCP) ([\\d\\.]*) ([\\d\\.a-f\\:]*) (\\d*)" +
+            " typ ([a-z]*)( raddr ([\\d\\.a-f\\:]*) rport (\\d*))?" +
+            "( tcptype (active|passive|so))?.*$",
+        "fingerprint": "^a=fingerprint:(sha-1|sha-256) ([A-Fa-f\\d\:]+).*$",
+        "setup": "^a=setup:(actpass|active|passive).*$",
+        "sctpmap": "^a=sctpmap:${port} ([\\w\\-]+)( [\\d]+)?.*$"
+    };
+
+    var templates = {
+        "sdp":
+            "v=${version}\r\n" +
+            "o=${username} ${sessionId} ${sessionVersion} ${netType} ${addressType} ${address}\r\n" +
+            "s=${sessionName}\r\n" +
+            "t=${startTime} ${stopTime}\r\n" +
+            "${msidsemanticLine}",
+
+        "msidsemantic": "a=msid-semantic:WMS ${mediaStreamIds}\r\n",
+
+        "mblock":
+            "m=${type} ${port} ${protocol} ${fmt}\r\n" +
+            "c=${netType} ${addressType} ${address}\r\n" +
+            "${rtcpLine}" +
+            "${rtcpMuxLine}" +
+            "a=${mode}\r\n" +
+            "${rtpMapLines}" +
+            "${fmtpLines}" +
+            "${nackLines}" +
+            "${nackpliLines}" +
+            "${ccmfirLines}" +
+            "${ericScreamLines}" +
+            "${cnameLines}" +
+            "${msidLines}" +
+            "${iceCredentialLines}" +
+            "${candidateLines}" +
+            "${dtlsFingerprintLine}" +
+            "${dtlsSetupLine}" +
+            "${sctpmapLine}",
+
+        "rtcp": "a=rtcp:${port}${[ ]netType}${[ ]addressType}${[ ]address}\r\n",
+        "rtcpMux": "a=rtcp-mux\r\n",
+
+        "rtpMap": "a=rtpmap:${type} ${encodingName}/${clockRate}${[/]channels}\r\n",
+        "fmtp": "a=fmtp:${type} ${parameters}\r\n",
+        "nack": "a=rtcp-fb:${type} nack\r\n",
+        "nackpli": "a=rtcp-fb:${type} nack pli\r\n",
+        "ccmfir": "a=rtcp-fb:${type} ccm fir\r\n",
+        "ericscream": "a=rtcp-fb:${type} ericscream\r\n",
+
+        "cname": "a=ssrc:${ssrc} cname:${cname}\r\n",
+        "msid": "a=msid:${mediaStreamId} ${mediaStreamTrackId}\r\n",
+
+        "iceCredentials":
+            "a=ice-ufrag:${ufrag}\r\n" +
+            "a=ice-pwd:${password}\r\n",
+
+        "candidate":
+            "a=candidate:${foundation} ${componentId} ${transport} ${priority} ${address} ${port}" +
+            " typ ${type}${[ raddr ]relatedAddress}${[ rport ]relatedPort}${[ tcptype ]tcpType}\r\n",
+
+        "dtlsFingerprint": "a=fingerprint:${fingerprintHashFunction} ${fingerprint}\r\n",
+        "dtlsSetup": "a=setup:${setup}\r\n",
+
+        "sctpmap": "a=sctpmap:${port} ${app}${[ ]streams}\r\n"
+    };
+
+    function match(data, pattern, flags, alt) {
+        var r = new RegExp(pattern, flags);
+        return data.match(r) || alt && alt.match(r) || null;
+    }
+
+    function addDefaults(obj, defaults) {
+        for (var p in defaults) {
+            if (!defaults.hasOwnProperty(p))
+                continue;
+            if (typeof(obj[p]) == "undefined")
+                obj[p] = defaults[p];
+        }
+    }
+
+    function fillTemplate(template, info) {
+        var text = template;
+        for (var p in info) {
+            if (!info.hasOwnProperty(p))
+                continue;
+            var r = new RegExp("\\${(\\[[^\\]]+\\])?" + p + "(\\[[^\\]]+\\])?}");
+            text = text.replace(r, function (_, prefix, suffix) {
+                if (!info[p] && info[p] != 0)
+                    return "";
+                prefix = prefix ? prefix.substr(1, prefix.length - 2) : "";
+                suffix = suffix ? suffix.substr(1, suffix.length - 2) : "";
+                return prefix + info[p] + suffix;
+            });
+        }
+        return text;
+    }
+
+    SDP.parse = function (sdpText) {
+        sdpText = new String(sdpText);
+        var sdpObj = {};
+        var parts = sdpText.split(new RegExp(regexps.mblock, "m")) || [sdpText];
+        var sblock = parts.shift();
+        var version = parseInt((match(sblock, regexps.vline, "m") || [])[1]);
+        if (!isNaN(version))
+            sdpObj.version = version;
+        var originator = match(sblock, regexps.oline, "m");;
+        if (originator) {
+            sdpObj.originator = {
+                "username": originator[1],
+                "sessionId": originator[2],
+                "sessionVersion": parseInt(originator[3]),
+                "netType": "IN",
+                "addressType": originator[4],
+                "address": originator[5]
+            };
+        }
+        var sessionName = match(sblock, regexps.sline, "m");
+        if (sessionName)
+            sdpObj.sessionName = sessionName[1];
+        var sessionTime = match(sblock, regexps.tline, "m");
+        if (sessionTime) {
+            sdpObj.startTime = parseInt(sessionTime[1]);
+            sdpObj.stopTime = parseInt(sessionTime[2]);
+        }
+        var hasMediaStreamId = !!match(sblock, regexps.msidsemantic, "m");
+        sdpObj.mediaDescriptions = [];
+
+        for (var i = 0; i < parts.length; i += 5) {
+            var mediaDescription = {
+                "type": parts[i],
+                "port": parseInt(parts[i + 1]),
+                "protocol": parts[i + 2],
+            };
+            var fmt = parts[i + 3].replace(/^[\s\uFEFF\xA0]+/, '')
+                .split(/ +/)
+                .map(function (x) {
+                    return parseInt(x);
+                });
+            var mblock = parts[i + 4];
+
+            var connection = match(mblock, regexps.cline, "m", sblock);
+            if (connection) {
+                mediaDescription.netType = "IN";
+                mediaDescription.addressType = connection[1];
+                mediaDescription.address = connection[2];
+            }
+            var mode = match(mblock, regexps.mode, "m", sblock);
+            if (mode)
+                mediaDescription.mode = mode[1];
+
+            var payloadTypes = [];
+            if (match(mediaDescription.protocol, "(UDP/TLS)?RTP/S?AVPF?")) {
+                mediaDescription.payloads = [];
+                payloadTypes = fmt;
+            }
+            payloadTypes.forEach(function (payloadType) {
+                var payload = { "type": payloadType };
+                var rtpmapLine = fillTemplate(regexps.rtpmap, payload);
+                var rtpmap = match(mblock, rtpmapLine, "m");
+                if (rtpmap) {
+                    payload.encodingName = rtpmap[1];
+                    payload.clockRate = parseInt(rtpmap[2]);
+                    if (mediaDescription.type == "audio")
+                        payload.channels = parseInt(rtpmap[3]) || 1;
+                    else if (mediaDescription.type == "video") {
+                        var nackLine = fillTemplate(regexps.nack, payload);
+                        payload.nack = !!match(mblock, nackLine, "m");
+                        var nackpliLine = fillTemplate(regexps.nackpli, payload);
+                        payload.nackpli = !!match(mblock, nackpliLine, "m");
+                        var ccmfirLine = fillTemplate(regexps.ccmfir, payload);
+                        payload.ccmfir = !!match(mblock, ccmfirLine, "m");
+                        var ericScreamLine = fillTemplate(regexps.ericscream, payload);
+                        payload.ericscream = !!match(mblock, ericScreamLine, "m");
+                    }
+                } else if (payloadType == 0 || payloadType == 8) {
+                    payload.encodingName = payloadType == 8 ? "PCMA" : "PCMU";
+                    payload.clockRate = 8000;
+                    payload.channels = 1;
+                }
+                var fmtpLine = fillTemplate(regexps.fmtp, payload);
+                var fmtp = match(mblock, fmtpLine, "m");
+                if (fmtp) {
+                    payload.parameters = {};
+                    fmtp[1].replace(new RegExp(regexps.param, "g"),
+                        function(_, key, value) {
+                            key = key.replace(/-([a-z])/g, function (_, c) {
+                                return c.toUpperCase();
+                            });
+                            payload.parameters[key] = isNaN(+value) ? value : +value;
+                    });
+                }
+                mediaDescription.payloads.push(payload);
+            });
+
+            var rtcp = match(mblock, regexps.rtcp, "m");
+            if (rtcp) {
+                mediaDescription.rtcp = {
+                    "netType": "IN",
+                    "port": parseInt(rtcp[1])
+                };
+                if (rtcp[2]) {
+                    mediaDescription.rtcp.addressType = rtcp[3];
+                    mediaDescription.rtcp.address = rtcp[4];
+                }
+            }
+            var rtcpmux = match(mblock, regexps.rtcpmux, "m", sblock);
+            if (rtcpmux) {
+                if (!mediaDescription.rtcp)
+                    mediaDescription.rtcp = {};
+                mediaDescription.rtcp.mux = true;
+            }
+
+            var cnameLines = match(mblock, regexps.cname, "mg");
+            if (cnameLines) {
+                mediaDescription.ssrcs = [];
+                cnameLines.forEach(function (line) {
+                    var cname = match(line, regexps.cname, "m");
+                    mediaDescription.ssrcs.push(parseInt(cname[1]));
+                    if (!mediaDescription.cname)
+                        mediaDescription.cname = cname[2];
+                });
+            }
+
+            if (hasMediaStreamId) {
+                var msid = match(mblock, regexps.msid, "m");
+                if (msid) {
+                    mediaDescription.mediaStreamId = msid[2];
+                    mediaDescription.mediaStreamTrackId = msid[3];
+                }
+            }
+
+            var ufrag = match(mblock, regexps.ufrag, "m", sblock);
+            var pwd = match(mblock, regexps.pwd, "m", sblock);
+            if (ufrag && pwd) {
+                mediaDescription.ice = {
+                    "ufrag": ufrag[1],
+                    "password": pwd[1]
+                };
+            }
+            var candidateLines = match(mblock, regexps.candidate, "mig");
+            if (candidateLines) {
+                if (!mediaDescription.ice)
+                    mediaDescription.ice = {};
+                mediaDescription.ice.candidates = [];
+                candidateLines.forEach(function (line) {
+                    var candidateLine = match(line, regexps.candidate, "mi");
+                    var candidate = {
+                        "foundation": candidateLine[1],
+                        "componentId": parseInt(candidateLine[2]),
+                        "transport": candidateLine[3].toUpperCase(),
+                        "priority": parseInt(candidateLine[4]),
+                        "address": candidateLine[5],
+                        "port": parseInt(candidateLine[6]),
+                        "type": candidateLine[7]
+                    };
+                    if (candidateLine[9])
+                        candidate.relatedAddress = candidateLine[9];
+                    if (!isNaN(candidateLine[10]))
+                        candidate.relatedPort = parseInt(candidateLine[10]);
+                    if (candidateLine[12])
+                        candidate.tcpType = candidateLine[12];
+                    else if (candidate.transport == "TCP") {
+                        if (candidate.port == 0 || candidate.port == 9) {
+                            candidate.tcpType = "active";
+                            candidate.port = 9;
+                        } else {
+                            return;
+                        }
+                    }
+                    mediaDescription.ice.candidates.push(candidate);
+                });
+            }
+
+            var fingerprint = match(mblock, regexps.fingerprint, "mi", sblock);
+            if (fingerprint) {
+                mediaDescription.dtls = {
+                    "fingerprintHashFunction": fingerprint[1].toLowerCase(),
+                    "fingerprint": fingerprint[2].toUpperCase()
+                };
+            }
+            var setup = match(mblock, regexps.setup, "m", sblock);
+            if (setup) {
+                if (!mediaDescription.dtls)
+                    mediaDescription.dtls = {};
+                mediaDescription.dtls.setup = setup[1];
+            }
+
+            if (mediaDescription.protocol == "DTLS/SCTP") {
+                mediaDescription.sctp = {
+                    "port": fmt[0]
+                };
+                var sctpmapLine = fillTemplate(regexps.sctpmap, mediaDescription.sctp);
+                var sctpmap = match(mblock, sctpmapLine, "m");
+                if (sctpmap) {
+                    mediaDescription.sctp.app = sctpmap[1];
+                    if (sctpmap[2])
+                        mediaDescription.sctp.streams = parseInt(sctpmap[2]);
+                }
+            }
+
+            sdpObj.mediaDescriptions.push(mediaDescription);
+        }
+
+        return sdpObj;
+    };
+
+    SDP.generate = function (sdpObj) {
+        sdpObj = JSON.parse(JSON.stringify(sdpObj));
+        addDefaults(sdpObj, {
+            "version": 0,
+            "originator": {},
+            "sessionName": "-",
+            "startTime": 0,
+            "stopTime": 0,
+            "mediaDescriptions": []
+        });
+        addDefaults(sdpObj.originator, {
+            "username": "-",
+            "sessionId": "" + Math.floor((Math.random() + +new Date()) * 1e6),
+            "sessionVersion": 1,
+            "netType": "IN",
+            "addressType": "IP4",
+            "address": "127.0.0.1"
+        });
+        var sdpText = fillTemplate(templates.sdp, sdpObj);
+        sdpText = fillTemplate(sdpText, sdpObj.originator);
+
+        var msidsemanticLine = "";
+        var mediaStreamIds = [];
+        sdpObj.mediaDescriptions.forEach(function (mdesc) {
+            if (mdesc.mediaStreamId && mdesc.mediaStreamTrackId
+                && mediaStreamIds.indexOf(mdesc.mediaStreamId) == -1)
+                mediaStreamIds.push(mdesc.mediaStreamId);
+        });
+        if (mediaStreamIds.length) {
+            var msidsemanticLine = fillTemplate(templates.msidsemantic,
+                { "mediaStreamIds": mediaStreamIds.join(" ") });
+        }
+        sdpText = fillTemplate(sdpText, { "msidsemanticLine": msidsemanticLine });
+
+        sdpObj.mediaDescriptions.forEach(function (mediaDescription) {
+            addDefaults(mediaDescription, {
+                "port": 9,
+                "protocol": "UDP/TLS/RTP/SAVPF",
+                "netType": "IN",
+                "addressType": "IP4",
+                "address": "0.0.0.0",
+                "mode": "sendrecv",
+                "payloads": [],
+                "rtcp": {}
+            });
+            var mblock = fillTemplate(templates.mblock, mediaDescription);
+
+            var payloadInfo = {"rtpMapLines": "", "fmtpLines": "", "nackLines": "",
+                "nackpliLines": "", "ccmfirLines": "", "ericScreamLines": ""};
+            mediaDescription.payloads.forEach(function (payload) {
+                if (payloadInfo.fmt)
+                    payloadInfo.fmt += " " + payload.type;
+                else
+                    payloadInfo.fmt = payload.type;
+                if (!payload.channels || payload.channels == 1)
+                    payload.channels = null;
+                payloadInfo.rtpMapLines += fillTemplate(templates.rtpMap, payload);
+                if (payload.parameters) {
+                    var fmtpInfo = { "type": payload.type, "parameters": "" };
+                    for (var p in payload.parameters) {
+                        var param = p.replace(/([A-Z])([a-z])/g, function (_, a, b) {
+                            return "-" + a.toLowerCase() + b;
+                        });
+                        if (fmtpInfo.parameters)
+                            fmtpInfo.parameters += ";";
+                        fmtpInfo.parameters += param + "=" + payload.parameters[p];
+                    }
+                    payloadInfo.fmtpLines += fillTemplate(templates.fmtp, fmtpInfo);
+                }
+                if (payload.nack)
+                    payloadInfo.nackLines += fillTemplate(templates.nack, payload);
+                if (payload.nackpli)
+                    payloadInfo.nackpliLines += fillTemplate(templates.nackpli, payload);
+                if (payload.ccmfir)
+                    payloadInfo.ccmfirLines += fillTemplate(templates.ccmfir, payload);
+                if (payload.ericscream)
+                    payloadInfo.ericScreamLines += fillTemplate(templates.ericscream, payload);
+            });
+            mblock = fillTemplate(mblock, payloadInfo);
+
+            var rtcpInfo = {"rtcpLine": "", "rtcpMuxLine": ""};
+            if (mediaDescription.rtcp.port) {
+                addDefaults(mediaDescription.rtcp, {
+                    "netType": "IN",
+                    "addressType": "IP4",
+                    "address": ""
+                });
+                if (!mediaDescription.rtcp.address)
+                    mediaDescription.rtcp.netType = mediaDescription.rtcp.addressType = "";
+                rtcpInfo.rtcpLine = fillTemplate(templates.rtcp, mediaDescription.rtcp);
+            }
+            if (mediaDescription.rtcp.mux)
+                rtcpInfo.rtcpMuxLine = templates.rtcpMux;
+            mblock = fillTemplate(mblock, rtcpInfo);
+
+            var srcAttributeLines = { "cnameLines": "", "msidLines": "" };
+            var srcAttributes = {
+                "cname": mediaDescription.cname,
+                "mediaStreamId": mediaDescription.mediaStreamId,
+                "mediaStreamTrackId": mediaDescription.mediaStreamTrackId
+            };
+            if (mediaDescription.cname && mediaDescription.ssrcs) {
+                mediaDescription.ssrcs.forEach(function (ssrc) {
+                    srcAttributes.ssrc = ssrc;
+                    srcAttributeLines.cnameLines += fillTemplate(templates.cname, srcAttributes);
+                    if (mediaDescription.mediaStreamId && mediaDescription.mediaStreamTrackId)
+                        srcAttributeLines.msidLines += fillTemplate(templates.msid, srcAttributes);
+                });
+            } else if (mediaDescription.mediaStreamId && mediaDescription.mediaStreamTrackId) {
+                srcAttributes.ssrc = null;
+                srcAttributeLines.msidLines += fillTemplate(templates.msid, srcAttributes);
+            }
+            mblock = fillTemplate(mblock, srcAttributeLines);
+
+            var iceInfo = {"iceCredentialLines": "", "candidateLines": ""};
+            if (mediaDescription.ice) {
+                iceInfo.iceCredentialLines = fillTemplate(templates.iceCredentials,
+                    mediaDescription.ice);
+                if (mediaDescription.ice.candidates) {
+                    mediaDescription.ice.candidates.forEach(function (candidate) {
+                        addDefaults(candidate, {
+                            "relatedAddress": null,
+                            "relatedPort": null,
+                            "tcpType": null
+                        });
+                        iceInfo.candidateLines += fillTemplate(templates.candidate, candidate);
+                    });
+                }
+            }
+            mblock = fillTemplate(mblock, iceInfo);
+
+            var dtlsInfo = { "dtlsFingerprintLine": "", "dtlsSetupLine": "" };
+            if (mediaDescription.dtls) {
+                if (mediaDescription.dtls.fingerprint) {
+                    dtlsInfo.dtlsFingerprintLine = fillTemplate(templates.dtlsFingerprint,
+                        mediaDescription.dtls);
+                }
+                addDefaults(mediaDescription.dtls, {"setup": "actpass"});
+                dtlsInfo.dtlsSetupLine = fillTemplate(templates.dtlsSetup, mediaDescription.dtls);
+            }
+            mblock = fillTemplate(mblock, dtlsInfo);
+
+            var sctpInfo = {"sctpmapLine": "", "fmt": ""};
+            if (mediaDescription.sctp) {
+                addDefaults(mediaDescription.sctp, {"streams": null});
+                sctpInfo.sctpmapLine = fillTemplate(templates.sctpmap, mediaDescription.sctp);
+                sctpInfo.fmt = mediaDescription.sctp.port;
+            }
+            mblock = fillTemplate(mblock, sctpInfo);
+
+            sdpText += mblock;
+        });
+
+        return sdpText;
+    };
+
+    SDP.generateCandidateLine = function (candidateObj) {
+        addDefaults(candidateObj, {
+            "relatedAddress": null,
+            "relatedPort": null,
+            "tcpType": null
+        });
+
+        return fillTemplate(templates.candidate, candidateObj);
+    };
+
+})();
+
+function generate(json) {
+    var object = JSON.parse(json);
+    return SDP.generate(object);
+}
+
+function parse(sdp) {
+    var object = SDP.parse(sdp);
+    return JSON.stringify(object);
+}
+
+function generateCandidateLine(json) {
+    var candidate = JSON.parse(json);
+    return SDP.generateCandidateLine(candidate).substr(2);
+}
+
+function parseCandidateLine(candidateLine) {
+    var iceInfo = SDP.parse("m=application 0 NONE\r\na=" + candidateLine + "\r\n").mediaDescriptions[0].ice;
+    return JSON.stringify(iceInfo.candidates[0]);
+}
+
+if (typeof(module) != "undefined" && typeof(exports) != "undefined")
+    module.exports = SDP;
diff --git a/Source/WebCore/PlatformWPE.cmake b/Source/WebCore/PlatformWPE.cmake
index 375d71b..46c8e7b 100644
--- a/Source/WebCore/PlatformWPE.cmake
+++ b/Source/WebCore/PlatformWPE.cmake
@@ -48,6 +48,9 @@ list(APPEND WebCore_INCLUDE_DIRECTORIES
     ${WTF_DIR}
 )
 
+set(WebCore_SDP_PROCESSOR_SCRIPTS ${WEBCORE_DIR}/Modules/mediastream/sdp.js)
+set(WebCore_SDP_PROCESSOR_SCRIPTS_DEPENDENCIES ${WEBCORE_DIR}/platform/mediastream/gtk/SDPProcessorScriptResource.cpp)
+
 list(APPEND WebCore_SOURCES
     loader/soup/CachedRawResourceSoup.cpp
     loader/soup/SubresourceLoaderSoup.cpp
@@ -115,6 +118,7 @@ list(APPEND WebCore_SOURCES
     platform/graphics/gstreamer/MediaPlayerPrivateGStreamer.cpp
     platform/graphics/gstreamer/MediaPlayerPrivateGStreamerBase.cpp
     platform/graphics/gstreamer/MediaPlayerPrivateGStreamerMSE.cpp
+    platform/graphics/gstreamer/MediaPlayerPrivateGStreamerOwr.cpp
     platform/graphics/gstreamer/MediaSourceGStreamer.cpp
     platform/graphics/gstreamer/SourceBufferPrivateGStreamer.cpp
     platform/graphics/gstreamer/TextCombinerGStreamer.cpp
@@ -175,6 +179,9 @@ list(APPEND WebCore_SOURCES
 
     platform/linux/MemoryPressureHandlerLinux.cpp
 
+    platform/mediastream/glib/SDPProcessorScriptResourceGLib.cpp
+
+    platform/mediastream/openwebrtc/MediaEndpointOwr.cpp
     platform/mediastream/openwebrtc/OpenWebRTCUtilities.cpp
     platform/mediastream/openwebrtc/RealtimeMediaSourceCenterOwr.cpp
 
@@ -318,6 +325,15 @@ if (ENABLE_WEB_AUDIO)
     )
 endif ()
 
+if (ENABLE_MEDIA_STREAM)
+    list(APPEND WebCore_SYSTEM_INCLUDE_DIRECTORIES
+        ${OPENWEBRTC_INCLUDE_DIRS}
+    )
+    list(APPEND WebCore_LIBRARIES
+        ${OPENWEBRTC_LIBRARIES}
+    )
+endif ()
+
 if (ENABLE_SUBTLE_CRYPTO)
     list(APPEND WebCore_SOURCES
         crypto/CryptoAlgorithm.cpp
diff --git a/Source/WebCore/dom/EventNames.h b/Source/WebCore/dom/EventNames.h
index 7e2a136..0053a15 100644
--- a/Source/WebCore/dom/EventNames.h
+++ b/Source/WebCore/dom/EventNames.h
@@ -43,7 +43,6 @@ namespace WebCore {
     macro(abort) \
     macro(active) \
     macro(addsourcebuffer) \
-    macro(addstream) \
     macro(addtrack) \
     macro(animationend) \
     macro(animationiteration) \
@@ -169,7 +168,6 @@ namespace WebCore {
     macro(ratechange) \
     macro(readystatechange) \
     macro(removesourcebuffer) \
-    macro(removestream) \
     macro(removetrack) \
     macro(reset) \
     macro(resize) \
diff --git a/Source/WebCore/dom/EventNames.in b/Source/WebCore/dom/EventNames.in
index 3139cdf..c63d239 100644
--- a/Source/WebCore/dom/EventNames.in
+++ b/Source/WebCore/dom/EventNames.in
@@ -33,7 +33,6 @@ WheelEvent
 XMLHttpRequestProgressEvent
 AudioProcessingEvent conditional=WEB_AUDIO
 OfflineAudioCompletionEvent conditional=WEB_AUDIO
-MediaStreamEvent conditional=MEDIA_STREAM
 MediaStreamTrackEvent conditional=MEDIA_STREAM
 RTCIceCandidateEvent conditional=MEDIA_STREAM
 RTCDataChannelEvent conditional=MEDIA_STREAM
diff --git a/Source/WebCore/html/HTMLMediaElement.cpp b/Source/WebCore/html/HTMLMediaElement.cpp
index 577ab0c..6d9bcfc 100644
--- a/Source/WebCore/html/HTMLMediaElement.cpp
+++ b/Source/WebCore/html/HTMLMediaElement.cpp
@@ -129,6 +129,7 @@
 #endif
 
 #if ENABLE(MEDIA_STREAM)
+#include "DOMURL.h"
 #include "MediaStream.h"
 #include "MediaStreamRegistry.h"
 #endif
@@ -904,6 +905,7 @@ void HTMLMediaElement::setSrcObject(MediaStream* mediaStream)
     // https://bugs.webkit.org/show_bug.cgi?id=124896
 
     m_mediaStreamSrcObject = mediaStream;
+    setSrc(DOMURL::createPublicURL(ActiveDOMObject::scriptExecutionContext(), mediaStream));
 }
 #endif
 
@@ -5763,10 +5765,6 @@ void HTMLMediaElement::createMediaPlayer()
         m_mediaSource->close();
 #endif
 
-#if ENABLE(MEDIA_STREAM)
-    m_mediaStreamSrcObject = nullptr;
-#endif
-
 #if ENABLE(VIDEO_TRACK)
     forgetResourceSpecificTracks();
 #endif
diff --git a/Source/WebCore/platform/graphics/MediaPlayer.cpp b/Source/WebCore/platform/graphics/MediaPlayer.cpp
index 50cea33..90ac7f0 100644
--- a/Source/WebCore/platform/graphics/MediaPlayer.cpp
+++ b/Source/WebCore/platform/graphics/MediaPlayer.cpp
@@ -53,6 +53,9 @@
 
 #if USE(GSTREAMER)
 #include "MediaPlayerPrivateGStreamer.h"
+#if ENABLE(MEDIA_STREAM) && USE(OPENWEBRTC)
+#include "MediaPlayerPrivateGStreamerOwr.h"
+#endif
 #define PlatformMediaEngineClassName MediaPlayerPrivateGStreamer
 #endif
 
@@ -209,6 +212,11 @@ static void buildMediaEnginesVector()
         MediaPlayerPrivateQTKit::registerMediaEngine(addMediaEngine);
 #endif
 
+
+#if ENABLE(MEDIA_STREAM) && USE(GSTREAMER) && USE(OPENWEBRTC)
+    MediaPlayerPrivateGStreamerOwr::registerMediaEngine(addMediaEngine);
+#endif
+
 #if defined(PlatformMediaEngineClassName)
     PlatformMediaEngineClassName::registerMediaEngine(addMediaEngine);
 #endif
diff --git a/Source/WebCore/platform/graphics/gstreamer/MediaPlayerPrivateGStreamerOwr.cpp b/Source/WebCore/platform/graphics/gstreamer/MediaPlayerPrivateGStreamerOwr.cpp
new file mode 100644
index 0000000..d4efcec
--- /dev/null
+++ b/Source/WebCore/platform/graphics/gstreamer/MediaPlayerPrivateGStreamerOwr.cpp
@@ -0,0 +1,321 @@
+/*
+ *  Copyright (C) 2012 Collabora Ltd. All rights reserved.
+ *  Copyright (C) 2014, 2015 Igalia S.L. All rights reserved.
+ *  Copyright (C) 2015 Metrological All rights reserved.
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public
+ *  License as published by the Free Software Foundation; either
+ *  version 2 of the License, or (at your option) any later version.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free Software
+ *  Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
+ */
+
+
+#include "config.h"
+
+#if ENABLE(MEDIA_STREAM) && USE(GSTREAMER) && USE(OPENWEBRTC)
+#include "MediaPlayerPrivateGStreamerOwr.h"
+
+#include "GStreamerUtilities.h"
+#include "MediaPlayer.h"
+#include "MediaStreamPrivate.h"
+#include "NotImplemented.h"
+#include "RealtimeMediaSourceOwr.h"
+#include "URL.h"
+#include <gst/audio/streamvolume.h>
+#include <owr/owr.h>
+#include <owr/owr_gst_audio_renderer.h>
+#include <owr/owr_gst_video_renderer.h>
+#include <wtf/text/CString.h>
+
+GST_DEBUG_CATEGORY(webkit_openwebrtc_debug);
+#define GST_CAT_DEFAULT webkit_openwebrtc_debug
+
+namespace WebCore {
+
+MediaPlayerPrivateGStreamerOwr::MediaPlayerPrivateGStreamerOwr(MediaPlayer* player)
+    : MediaPlayerPrivateGStreamerBase(player)
+    , m_paused(true)
+    , m_stopped(true)
+{
+    if (isAvailable()) {
+        LOG_MEDIA_MESSAGE("Creating Stream media player");
+
+        createVideoSink();
+        createGSTAudioSinkBin();
+    }
+}
+
+MediaPlayerPrivateGStreamerOwr::~MediaPlayerPrivateGStreamerOwr()
+{
+    LOG_MEDIA_MESSAGE("Destructing");
+
+    stop();
+}
+
+void MediaPlayerPrivateGStreamerOwr::play()
+{
+    LOG_MEDIA_MESSAGE("Play");
+
+    if (!m_streamPrivate || !m_streamPrivate->active()) {
+        m_readyState = MediaPlayer::HaveNothing;
+        loadingFailed(MediaPlayer::Empty);
+        return;
+    }
+
+    m_paused = false;
+    internalLoad();
+}
+
+void MediaPlayerPrivateGStreamerOwr::pause()
+{
+    LOG_MEDIA_MESSAGE("Pause");
+    m_paused = true;
+    stop();
+}
+
+bool MediaPlayerPrivateGStreamerOwr::hasVideo() const
+{
+    return m_videoSource;
+}
+
+bool MediaPlayerPrivateGStreamerOwr::hasAudio() const
+{
+    return m_audioSource;
+}
+
+float MediaPlayerPrivateGStreamerOwr::currentTime() const
+{
+    gint64 position = GST_CLOCK_TIME_NONE;
+    GstQuery* query= gst_query_new_position(GST_FORMAT_TIME);
+
+    if (m_videoSource && gst_element_query(m_videoSink.get(), query))
+        gst_query_parse_position(query, 0, &position);
+    else if (m_audioSource && gst_element_query(m_audioSink.get(), query))
+        gst_query_parse_position(query, 0, &position);
+
+    float result = 0.0f;
+    if (static_cast<GstClockTime>(position) != GST_CLOCK_TIME_NONE)
+        result = static_cast<double>(position) / GST_SECOND;
+
+    LOG_MEDIA_MESSAGE("Position %" GST_TIME_FORMAT, GST_TIME_ARGS(position));
+    gst_query_unref(query);
+
+    return result;
+}
+
+void MediaPlayerPrivateGStreamerOwr::load(const String &url)
+{
+    notImplemented();
+}
+
+void MediaPlayerPrivateGStreamerOwr::load(MediaStreamPrivate& streamPrivate)
+{
+    if (!initializeGStreamer())
+        return;
+
+    LOG_MEDIA_MESSAGE("Loading MediaStreamPrivate %p", &streamPrivate);
+
+    m_streamPrivate = &streamPrivate;
+    if (!m_streamPrivate || !m_streamPrivate->active()) {
+        loadingFailed(MediaPlayer::NetworkError);
+        return;
+    }
+
+    m_readyState = MediaPlayer::HaveNothing;
+    m_networkState = MediaPlayer::Loading;
+    m_player->networkStateChanged();
+    m_player->readyStateChanged();
+
+    if (!internalLoad())
+        return;
+
+    // If the stream contains video, wait for first video frame before setting
+    // HaveEnoughData
+    if (!hasVideo())
+        m_readyState = MediaPlayer::HaveEnoughData;
+
+    m_player->readyStateChanged();
+
+}
+
+void MediaPlayerPrivateGStreamerOwr::loadingFailed(MediaPlayer::NetworkState error)
+{
+
+    if (m_networkState != error) {
+        m_networkState = error;
+        m_player->networkStateChanged();
+    }
+    if (m_readyState != MediaPlayer::HaveNothing) {
+        m_readyState = MediaPlayer::HaveNothing;
+        m_player->readyStateChanged();
+    }
+}
+
+bool MediaPlayerPrivateGStreamerOwr::didLoadingProgress() const
+{
+    return true;
+}
+
+bool MediaPlayerPrivateGStreamerOwr::internalLoad()
+{
+    if (!m_stopped)
+        return false;
+
+    m_stopped = false;
+    if (!m_streamPrivate || !m_streamPrivate->active()) {
+        loadingFailed(MediaPlayer::NetworkError);
+        return false;
+    }
+
+    LOG_MEDIA_MESSAGE("Connecting to live stream, descriptor: %p", m_streamPrivate.get());
+
+    for (auto track : m_streamPrivate->tracks()) {
+        if (!track->enabled()) {
+            LOG_MEDIA_MESSAGE("Track %s disabled", track->label().ascii().data());
+            continue;
+        }
+
+        RealtimeMediaSourceOwr* source = reinterpret_cast<RealtimeMediaSourceOwr*>(track->source());
+        OwrMediaSource* mediaSource = OWR_MEDIA_SOURCE(source->mediaSource());
+
+        if (track->type() == RealtimeMediaSource::Audio) {
+            if (m_audioSource && (m_audioSource.get() == source))
+                g_object_set(m_audioRenderer, "disabled", FALSE, nullptr);
+
+            owr_media_renderer_set_source(OWR_MEDIA_RENDERER(m_audioRenderer), mediaSource);
+            m_audioSource = source;
+            source->addObserver(this);
+        } else if (track->type() == RealtimeMediaSource::Video) {
+            if (m_videoSource && (m_videoSource.get() == source))
+                g_object_set(m_videoRenderer, "disabled", FALSE, nullptr);
+
+            owr_media_renderer_set_source(OWR_MEDIA_RENDERER(m_videoRenderer), mediaSource);
+            m_videoSource = source;
+            source->addObserver(this);
+        } else
+            ASSERT_NOT_REACHED();
+    }
+
+    m_readyState = MediaPlayer::HaveEnoughData;
+    m_player->readyStateChanged();
+    return true;
+}
+
+void MediaPlayerPrivateGStreamerOwr::stop()
+{
+    if (m_stopped)
+        return;
+
+    m_stopped = true;
+    if (m_audioSource) {
+        LOG_MEDIA_MESSAGE("Stop: disconnecting audio");
+        g_object_set(m_audioRenderer, "disabled", TRUE, nullptr);
+    }
+    if (m_videoSource) {
+        LOG_MEDIA_MESSAGE("Stop: disconnecting video");
+        g_object_set(m_videoRenderer, "disabled", TRUE, nullptr);
+    }
+}
+
+void MediaPlayerPrivateGStreamerOwr::registerMediaEngine(MediaEngineRegistrar registrar)
+{
+    if (isAvailable()) {
+        registrar([](MediaPlayer* player) {
+            return std::make_unique<MediaPlayerPrivateGStreamerOwr>(player);
+        }, getSupportedTypes, supportsType, 0, 0, 0, 0);
+    }
+}
+
+void MediaPlayerPrivateGStreamerOwr::getSupportedTypes(HashSet<String>& types)
+{
+    // FIXME
+}
+
+MediaPlayer::SupportsType MediaPlayerPrivateGStreamerOwr::supportsType(const MediaEngineSupportParameters& parameters)
+{
+    // FIXME
+    return MediaPlayer::IsNotSupported;
+}
+
+bool MediaPlayerPrivateGStreamerOwr::isAvailable()
+{
+    if (!initializeGStreamer())
+        return false;
+
+    static bool debugRegistered = false;
+    if (!debugRegistered) {
+        GST_DEBUG_CATEGORY_INIT(webkit_openwebrtc_debug, "webkitowrplayer", 0, "WebKit OpenWebRTC player");
+        debugRegistered = true;
+    }
+
+    return true;
+}
+
+void MediaPlayerPrivateGStreamerOwr::createGSTAudioSinkBin()
+{
+    ASSERT(!m_audioSink);
+    LOG_MEDIA_MESSAGE("Creating audio sink");
+    // FIXME: volume/mute support
+
+    GRefPtr<GstElement> sink = gst_element_factory_make("autoaudiosink", 0);
+    GstStateChangeReturn stateChangeResult = gst_element_set_state(sink.get(), GST_STATE_READY);
+    GstChildProxy* childProxy = GST_CHILD_PROXY(sink.get());
+    m_audioSink = adoptGRef(GST_ELEMENT(gst_child_proxy_get_child_by_index(childProxy, 0)));
+    gst_element_set_state(sink.get(), GST_STATE_NULL);
+
+    m_audioRenderer = owr_gst_audio_renderer_new(m_audioSink.get());
+}
+
+void MediaPlayerPrivateGStreamerOwr::sourceStopped()
+{
+    LOG_MEDIA_MESSAGE("Source stopped");
+
+    if (!m_streamPrivate || !m_streamPrivate->active())
+        stop();
+
+    for (auto track : m_streamPrivate->tracks()) {
+        RealtimeMediaSourceOwr* source = reinterpret_cast<RealtimeMediaSourceOwr*>(track->source());
+        if (track->enabled())
+            continue;
+        if (source == m_audioSource)
+            g_object_set(m_audioRenderer, "disabled", TRUE, nullptr);
+        else if (source == m_videoSource)
+            g_object_set(m_videoRenderer, "disabled", TRUE, nullptr);
+    }
+}
+
+void MediaPlayerPrivateGStreamerOwr::sourceMutedChanged()
+{
+    LOG_MEDIA_MESSAGE("Source muted state changed");
+}
+
+void MediaPlayerPrivateGStreamerOwr::sourceSettingsChanged()
+{
+    LOG_MEDIA_MESSAGE("Source settings changed");
+}
+
+bool MediaPlayerPrivateGStreamerOwr::preventSourceFromStopping()
+{
+    LOG_MEDIA_MESSAGE("Prevent source from stopping");
+    return false;
+}
+
+GstElement* MediaPlayerPrivateGStreamerOwr::createVideoSink()
+{
+    GstElement* sink = MediaPlayerPrivateGStreamerBase::createVideoSink();
+    m_videoRenderer = owr_gst_video_renderer_new(sink);
+    return nullptr;
+}
+
+} // namespace WebCore
+
+#endif // ENABLE(MEDIA_STREAM) && USE(GSTREAMER) && USE(OPENWEBRTC)
diff --git a/Source/WebCore/platform/graphics/gstreamer/MediaPlayerPrivateGStreamerOwr.h b/Source/WebCore/platform/graphics/gstreamer/MediaPlayerPrivateGStreamerOwr.h
new file mode 100644
index 0000000..acb7a0f
--- /dev/null
+++ b/Source/WebCore/platform/graphics/gstreamer/MediaPlayerPrivateGStreamerOwr.h
@@ -0,0 +1,118 @@
+/*
+ *  Copyright (C) 2015 Igalia S.L. All rights reserved.
+ *  Copyright (C) 2015 Metrological. All rights reserved.
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public
+ *  License as published by the Free Software Foundation; either
+ *  version 2 of the License, or (at your option) any later version.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free Software
+ *  Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
+ */
+
+#ifndef MediaPlayerPrivateGStreamerOwr_h
+#define MediaPlayerPrivateGStreamerOwr_h
+
+#if ENABLE(MEDIA_STREAM) && USE(GSTREAMER) && USE(OPENWEBRTC)
+
+#include "MediaPlayerPrivateGStreamerBase.h"
+#include "RealtimeMediaSource.h"
+
+typedef struct _OwrGstVideoRenderer OwrGstVideoRenderer;
+typedef struct _OwrGstAudioRenderer OwrGstAudioRenderer;
+
+namespace WebCore {
+
+class MediaStreamPrivate;
+class RealtimeMediaSourceOwr;
+class URL;
+
+class MediaPlayerPrivateGStreamerOwr : public MediaPlayerPrivateGStreamerBase, private RealtimeMediaSource::Observer {
+public:
+    explicit MediaPlayerPrivateGStreamerOwr(MediaPlayer*);
+    ~MediaPlayerPrivateGStreamerOwr();
+
+    static void registerMediaEngine(MediaEngineRegistrar);
+    virtual String engineDescription() const { return "OpenWebRTC"; }
+
+    virtual void load(const String&);
+#if ENABLE(MEDIA_SOURCE)
+    virtual void load(const String&, MediaSourcePrivateClient*) { }
+#endif
+    virtual void load(MediaStreamPrivate&);
+    virtual void cancelLoad() { }
+
+    virtual void prepareToPlay() { }
+    void play();
+    void pause();
+
+    bool hasVideo() const;
+    bool hasAudio() const;
+
+    virtual float duration() const { return 0; }
+
+    virtual float currentTime() const;
+    virtual void seek(float) { }
+    virtual bool seeking() const { return false; }
+
+    virtual void setRate(float) { }
+    virtual void setPreservesPitch(bool) { }
+    virtual bool paused() const { return m_paused; }
+
+    virtual bool hasClosedCaptions() const { return false; }
+    virtual void setClosedCaptionsVisible(bool) { };
+
+    virtual float maxTimeSeekable() const { return 0; }
+    virtual std::unique_ptr<PlatformTimeRanges> buffered() const { return std::make_unique<PlatformTimeRanges>(); }
+    bool didLoadingProgress() const;
+
+    virtual unsigned long long totalBytes() const { return 0; }
+    virtual unsigned bytesLoaded() const { return 0; }
+
+    virtual bool canLoadPoster() const { return false; }
+    virtual void setPoster(const String&) { }
+
+    virtual bool isLiveStream() const { return true; }
+
+    // RealtimeMediaSource::Observer implementation
+    virtual void sourceStopped() override final;
+    virtual void sourceMutedChanged() override final;
+    virtual void sourceSettingsChanged() override final;
+    virtual bool preventSourceFromStopping() override final;
+
+protected:
+    virtual GstElement* createVideoSink();
+
+private:
+    static void getSupportedTypes(HashSet<String>&);
+    static MediaPlayer::SupportsType supportsType(const MediaEngineSupportParameters&);
+    static bool isAvailable();
+    void createGSTAudioSinkBin();
+    void loadingFailed(MediaPlayer::NetworkState error);
+    bool internalLoad();
+    void stop();
+    virtual GstElement* audioSink() const { return m_audioSink.get(); }
+
+private:
+    bool m_paused;
+    bool m_stopped;
+    RefPtr<RealtimeMediaSourceOwr> m_videoSource;
+    RefPtr<RealtimeMediaSourceOwr> m_audioSource;
+    GRefPtr<GstElement> m_audioSink;
+    RefPtr<MediaStreamPrivate> m_streamPrivate;
+    OwrGstVideoRenderer* m_videoRenderer;
+    OwrGstAudioRenderer* m_audioRenderer;
+};
+
+} // namespace WebCore
+
+#endif // ENABLE(MEDIA_STREAM) && USE(GSTREAMER) && USE(OPENWEBRTC)
+
+#endif // MediaPlayerPrivateGStreamerOwr_h
diff --git a/Source/WebCore/platform/mediastream/IceCandidate.h b/Source/WebCore/platform/mediastream/IceCandidate.h
new file mode 100644
index 0000000..512a07a
--- /dev/null
+++ b/Source/WebCore/platform/mediastream/IceCandidate.h
@@ -0,0 +1,122 @@
+/*
+ * Copyright (C) 2015 Ericsson AB. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer
+ *    in the documentation and/or other materials provided with the
+ *    distribution.
+ * 3. Neither the name of Ericsson nor the names of its contributors
+ *    may be used to endorse or promote products derived from this
+ *    software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef IceCandidate_h
+#define IceCandidate_h
+
+#if ENABLE(MEDIA_STREAM)
+
+#include <wtf/RefCounted.h>
+#include <wtf/RefPtr.h>
+#include <wtf/text/WTFString.h>
+
+namespace WebCore {
+
+class IceCandidate : public RefCounted<IceCandidate> {
+public:
+    static RefPtr<IceCandidate> create()
+    {
+        return adoptRef(new IceCandidate());
+    }
+    virtual ~IceCandidate() { }
+
+    const String& type() const { return m_type; }
+    void setType(const String& type) { m_type = type; }
+
+    const String& foundation() const { return m_foundation; }
+    void setFoundation(const String& foundation) { m_foundation = foundation; }
+
+    unsigned componentId() const { return m_componentId; }
+    void setComponentId(unsigned componentId) { m_componentId = componentId; }
+
+    const String& transport() const { return m_transport; }
+    void setTransport(const String& transport) { m_transport = transport; }
+
+    int priority() const { return m_priority; }
+    void setPriority(int priority) { m_priority = priority; }
+
+    const String& address() const { return m_address; }
+    void setAddress(const String& address) { m_address = address; }
+
+    unsigned port() const { return m_port; }
+    void setPort(unsigned port) { m_port = port; }
+
+    const String& tcpType() const { return m_tcpType; }
+    void setTcpType(const String& tcpType) { m_tcpType = tcpType; }
+
+    const String& relatedAddress() const { return m_relatedAddress; }
+    void setRelatedAddress(const String& relatedAddress) { m_relatedAddress = relatedAddress; }
+
+    unsigned relatedPort() const { return m_relatedPort; }
+    void setRelatedPort(unsigned relatedPort) { m_relatedPort = relatedPort; }
+
+    RefPtr<IceCandidate> clone() const
+    {
+        RefPtr<IceCandidate> copy = create();
+
+        copy->m_type = String(m_type);
+        copy->m_foundation = String(m_foundation);
+        copy->m_componentId = m_componentId;
+        copy->m_transport = String(m_transport);
+        copy->m_priority = m_priority;
+        copy->m_address = String(m_address);
+        copy->m_port = m_port;
+        copy->m_tcpType = String(m_tcpType);
+        copy->m_relatedAddress = String(m_relatedAddress);
+        copy->m_relatedPort = m_relatedPort;
+
+        return copy;
+    }
+
+private:
+    IceCandidate()
+        : m_componentId(0)
+        , m_priority(0)
+        , m_port(0)
+        , m_relatedPort(0)
+    { }
+
+    String m_type;
+    String m_foundation;
+    unsigned m_componentId;
+    String m_transport;
+    int m_priority;
+    String m_address;
+    unsigned m_port;
+    String m_tcpType;
+    String m_relatedAddress;
+    unsigned m_relatedPort;
+};
+
+} // namespace WebCore
+
+#endif // ENABLE(MEDIA_STREAM)
+
+#endif // IceCandidate_h
diff --git a/Source/WebCore/platform/mediastream/MediaEndpoint.cpp b/Source/WebCore/platform/mediastream/MediaEndpoint.cpp
new file mode 100644
index 0000000..e1f5d7e
--- /dev/null
+++ b/Source/WebCore/platform/mediastream/MediaEndpoint.cpp
@@ -0,0 +1,21 @@
+/*
+ *
+ */
+
+#include "config.h"
+
+#if ENABLE(MEDIA_STREAM)
+#include "MediaEndpoint.h"
+
+namespace WebCore {
+
+static std::unique_ptr<MediaEndpoint> createMediaEndpoint(MediaEndpointClient*)
+{
+    return nullptr;
+}
+
+CreateMediaEndpoint MediaEndpoint::create = createMediaEndpoint;
+
+} // namespace WebCore
+
+#endif // ENABLE(MEDIA_STREAM)
diff --git a/Source/WebCore/platform/mediastream/MediaEndpoint.h b/Source/WebCore/platform/mediastream/MediaEndpoint.h
new file mode 100644
index 0000000..9e8b385
--- /dev/null
+++ b/Source/WebCore/platform/mediastream/MediaEndpoint.h
@@ -0,0 +1,92 @@
+/*
+ * Copyright (C) 2015 Ericsson AB. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer
+ *    in the documentation and/or other materials provided with the
+ *    distribution.
+ * 3. Neither the name of Ericsson nor the names of its contributors
+ *    may be used to endorse or promote products derived from this
+ *    software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef MediaEndpoint_h
+#define MediaEndpoint_h
+
+#if ENABLE(MEDIA_STREAM)
+
+// #include "RTCConfigurationPrivate.h"
+#include "MediaEndpointInit.h"
+#include <wtf/text/WTFString.h>
+
+namespace WebCore {
+
+class IceCandidate;
+class MediaEndpoint;
+class MediaEndpointConfiguration;
+class MediaPayload;
+class RealtimeMediaSource;
+
+class MediaEndpointClient {
+public:
+    virtual void gotDtlsFingerprint(const String& fingerprint, const String& fingerprintFunction) = 0;
+    virtual void gotIceCandidate(unsigned mdescIndex, RefPtr<IceCandidate>&&) = 0;
+    virtual void doneGatheringCandidates(unsigned mdescIndex) = 0;
+    virtual void gotRemoteSource(unsigned mdescIndex, RefPtr<RealtimeMediaSource>&&) = 0;
+
+    virtual ~MediaEndpointClient() { }
+};
+
+typedef std::unique_ptr<MediaEndpoint> (*CreateMediaEndpoint)(MediaEndpointClient*);
+
+enum class MediaEndpointPrepareResult {
+    Success,
+    SuccessWithIceRestart,
+    Failed
+};
+
+class MediaEndpoint {
+public:
+    WEBCORE_EXPORT static CreateMediaEndpoint create;
+    virtual ~MediaEndpoint() { }
+
+    // FIMXE: look over naming
+    virtual void setConfiguration(RefPtr<MediaEndpointInit>&&) = 0;
+
+    virtual void getDtlsFingerprint() = 0;
+    virtual Vector<RefPtr<MediaPayload>> getDefaultAudioPayloads() = 0;
+    virtual Vector<RefPtr<MediaPayload>> getDefaultVideoPayloads() = 0;
+
+    virtual MediaEndpointPrepareResult prepareToReceive(MediaEndpointConfiguration*, bool isInitiator) = 0;
+    virtual MediaEndpointPrepareResult prepareToSend(MediaEndpointConfiguration*, bool isInitiator) = 0;
+
+    virtual void addRemoteCandidate(IceCandidate&, unsigned mdescIndex, const String& ufrag, const String& password) = 0;
+
+    virtual void replaceSendSource(RealtimeMediaSource&, unsigned mdescIndex) = 0;
+
+    virtual void stop() = 0;
+};
+
+} // namespace WebCore
+
+#endif // ENABLE(MEDIA_STREAM)
+
+#endif // MediaEndpoint_h
diff --git a/Source/WebCore/platform/mediastream/MediaEndpointConfiguration.h b/Source/WebCore/platform/mediastream/MediaEndpointConfiguration.h
new file mode 100644
index 0000000..9274aba
--- /dev/null
+++ b/Source/WebCore/platform/mediastream/MediaEndpointConfiguration.h
@@ -0,0 +1,86 @@
+/*
+ * Copyright (C) 2015 Ericsson AB. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer
+ *    in the documentation and/or other materials provided with the
+ *    distribution.
+ * 3. Neither the name of Ericsson nor the names of its contributors
+ *    may be used to endorse or promote products derived from this
+ *    software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef MediaEndpointConfiguration_h
+#define MediaEndpointConfiguration_h
+
+#if ENABLE(MEDIA_STREAM)
+
+#include "PeerMediaDescription.h"
+#include <wtf/CryptographicallyRandomNumber.h>
+
+namespace WebCore {
+
+class MediaEndpointConfiguration : public RefCounted<MediaEndpointConfiguration> {
+public:
+    static RefPtr<MediaEndpointConfiguration> create()
+    {
+        return adoptRef(new MediaEndpointConfiguration());
+    }
+    virtual ~MediaEndpointConfiguration() { }
+
+    uint64_t sessionId() const { return m_sessionId; }
+    void setSessionId(uint64_t sessionId) { m_sessionId = sessionId; }
+
+    unsigned sessionVersion() const { return m_sessionVersion; }
+    void setSessionVersion(unsigned sessionVersion) { m_sessionVersion = sessionVersion; }
+
+    const Vector<RefPtr<PeerMediaDescription>>& mediaDescriptions() const { return m_mediaDescriptions; }
+    void addMediaDescription(RefPtr<PeerMediaDescription>&& description) { m_mediaDescriptions.append(WTF::move(description)); }
+
+    RefPtr<MediaEndpointConfiguration> clone() const
+    {
+        RefPtr<MediaEndpointConfiguration> copy = create();
+        copy->m_sessionId = m_sessionId;
+        copy->m_sessionVersion = m_sessionVersion;
+
+        for (auto& mdesc : m_mediaDescriptions)
+            copy->m_mediaDescriptions.append(mdesc->clone());
+
+        return copy;
+    }
+
+private:
+    MediaEndpointConfiguration()
+        : m_sessionId(cryptographicallyRandomNumber()) // FIXME: should be 64 bits
+        , m_sessionVersion(0)
+    { }
+
+    uint64_t m_sessionId;
+    unsigned m_sessionVersion;
+
+    Vector<RefPtr<PeerMediaDescription>> m_mediaDescriptions;
+};
+
+} // namespace WebCore
+
+#endif // ENABLE(MEDIA_STREAM)
+
+#endif // MediaEndpointConfiguration_h
diff --git a/Source/WebCore/platform/mediastream/MediaEndpointInit.cpp b/Source/WebCore/platform/mediastream/MediaEndpointInit.cpp
new file mode 100644
index 0000000..37a30d3
--- /dev/null
+++ b/Source/WebCore/platform/mediastream/MediaEndpointInit.cpp
@@ -0,0 +1,62 @@
+/*
+ * Copyright (C) 2015 Ericsson AB. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer
+ *    in the documentation and/or other materials provided with the
+ *    distribution.
+ * 3. Neither the name of Ericsson nor the names of its contributors
+ *    may be used to endorse or promote products derived from this
+ *    software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include "config.h"
+#include "MediaEndpointInit.h"
+
+#if ENABLE(MEDIA_STREAM)
+
+namespace WebCore {
+
+MediaEndpointInit::MediaEndpointInit(Vector<RefPtr<IceServerInfo>>& iceServers, const String& iceTransportPolicy, const String& bundlePolicy)
+    : m_iceServers(iceServers)
+{
+    if (iceTransportPolicy == "none")
+        m_iceTransportPolicy = IceTransportPolicyNone;
+    else if (iceTransportPolicy == "relay")
+        m_iceTransportPolicy = IceTransportPolicyRelay;
+    else if (iceTransportPolicy == "all")
+        m_iceTransportPolicy = IceTransportPolicyAll;
+    else
+        ASSERT_NOT_REACHED();
+
+    if (bundlePolicy == "balanced")
+        m_bundlePolicy = BundlePolicyBalanced;
+    else if (bundlePolicy == "max-compat")
+        m_bundlePolicy = BundlePolicyMaxCompat;
+    else if (bundlePolicy == "max-bundle")
+        m_bundlePolicy = BundlePolicyMaxBundle;
+    else
+        ASSERT_NOT_REACHED();
+}
+
+} // namespace WebCore
+
+#endif // ENABLE(MEDIA_STREAM)
diff --git a/Source/WebCore/platform/mediastream/MediaEndpointInit.h b/Source/WebCore/platform/mediastream/MediaEndpointInit.h
new file mode 100644
index 0000000..6c1ddbd
--- /dev/null
+++ b/Source/WebCore/platform/mediastream/MediaEndpointInit.h
@@ -0,0 +1,102 @@
+/*
+ * Copyright (C) 2015 Ericsson AB. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer
+ *    in the documentation and/or other materials provided with the
+ *    distribution.
+ * 3. Neither the name of Ericsson nor the names of its contributors
+ *    may be used to endorse or promote products derived from this
+ *    software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef MediaEndpointInit_h
+#define MediaEndpointInit_h
+
+#if ENABLE(MEDIA_STREAM)
+
+#include <wtf/RefCounted.h>
+#include <wtf/RefPtr.h>
+#include <wtf/Vector.h>
+#include <wtf/text/WTFString.h>
+
+namespace WebCore {
+
+class IceServerInfo : public RefCounted<IceServerInfo> {
+public:
+    static RefPtr<IceServerInfo> create(const Vector<String>& urls, const String& credential, const String& username)
+    {
+        return adoptRef(new IceServerInfo(urls, credential, username));
+    }
+    virtual ~IceServerInfo() { }
+
+    const Vector<String>& urls() const { return m_urls; }
+    const String& credential() const { return m_credential; }
+    const String& username() const { return m_username; }
+
+private:
+    IceServerInfo(const Vector<String>& urls, const String& credential, const String& username)
+        : m_urls(urls)
+        , m_credential(credential)
+        , m_username(username)
+    { }
+
+    Vector<String> m_urls;
+    String m_credential;
+    String m_username;
+};
+
+class MediaEndpointInit : public RefCounted<MediaEndpointInit> {
+public:
+    static RefPtr<MediaEndpointInit> create(Vector<RefPtr<IceServerInfo>>& iceServers, const String& iceTransportPolicy, const String& bundlePolicy)
+    {
+        return adoptRef(new MediaEndpointInit(iceServers, iceTransportPolicy, bundlePolicy));
+    }
+
+    enum IceTransportPolicy {
+        IceTransportPolicyNone,
+        IceTransportPolicyRelay,
+        IceTransportPolicyAll
+    };
+
+    enum BundlePolicy {
+        BundlePolicyBalanced,
+        BundlePolicyMaxCompat,
+        BundlePolicyMaxBundle
+    };
+
+    const Vector<RefPtr<IceServerInfo>>& iceServers() const { return m_iceServers; }
+    IceTransportPolicy iceTransportPolicy() const { return m_iceTransportPolicy; }
+    BundlePolicy bundlePolicy() const { return m_bundlePolicy; }
+
+private:
+    MediaEndpointInit(Vector<RefPtr<IceServerInfo>>&, const String& iceTransportPolicy, const String& bundlePolicy);
+
+    Vector<RefPtr<IceServerInfo>> m_iceServers;
+    IceTransportPolicy m_iceTransportPolicy;
+    BundlePolicy m_bundlePolicy;
+};
+
+} // namespace WebCore
+
+#endif // ENABLE(MEDIA_STREAM)
+
+#endif // MediaEndpointInit_h
diff --git a/Source/WebCore/platform/mediastream/MediaPayload.h b/Source/WebCore/platform/mediastream/MediaPayload.h
new file mode 100644
index 0000000..c3e2ef6
--- /dev/null
+++ b/Source/WebCore/platform/mediastream/MediaPayload.h
@@ -0,0 +1,124 @@
+/*
+ * Copyright (C) 2015 Ericsson AB. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer
+ *    in the documentation and/or other materials provided with the
+ *    distribution.
+ * 3. Neither the name of Ericsson nor the names of its contributors
+ *    may be used to endorse or promote products derived from this
+ *    software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef MediaPayload_h
+#define MediaPayload_h
+
+#if ENABLE(MEDIA_STREAM)
+
+#include <wtf/HashMap.h>
+#include <wtf/RefCounted.h>
+#include <wtf/RefPtr.h>
+#include <wtf/text/StringHash.h>
+
+namespace WebCore {
+
+class MediaPayload : public RefCounted<MediaPayload> {
+public:
+    static RefPtr<MediaPayload> create()
+    {
+        return adoptRef(new MediaPayload());
+    }
+    virtual ~MediaPayload() { }
+
+    unsigned type() const { return m_type; }
+    void setType(unsigned type) { m_type = type; }
+
+    const String& encodingName() const { return m_encodingName; }
+    void setEncodingName(const String & encodingName) { m_encodingName = encodingName; }
+
+    unsigned clockRate() const { return m_clockRate; }
+    void setClockRate(unsigned clockRate) { m_clockRate = clockRate; }
+
+    unsigned channels() const { return m_channels; }
+    void setChannels(unsigned channels) { m_channels = channels; }
+
+    bool ccmfir() const { return m_ccmfir; }
+    void setCcmfir(bool ccmfir) { m_ccmfir = ccmfir; }
+
+    bool nackpli() const { return m_nackpli; }
+    void setNackpli(bool nackpli) { m_nackpli = nackpli; }
+
+    bool nack() const { return m_nack; }
+    void setNack(bool nack) { m_nack = nack; }
+
+    const HashMap<String, unsigned>& parameters() const { return m_parameters; }
+    void addParameter(const String& name, unsigned value) { m_parameters.set(name, value); }
+
+    RefPtr<MediaPayload> clone() const
+    {
+        RefPtr<MediaPayload> copy = create();
+
+        copy->m_type = m_type;
+        copy->m_encodingName = String(m_encodingName);
+        copy->m_clockRate = m_clockRate;
+
+        copy->m_channels = m_channels;
+
+        copy->m_ccmfir = m_ccmfir;
+        copy->m_nackpli = m_nackpli;
+        copy->m_nack = m_nack;
+
+        for (auto& key : m_parameters.keys())
+            copy->m_parameters.add(key, m_parameters.get(key));
+
+        return copy;
+    }
+
+private:
+    MediaPayload()
+        : m_type(0)
+        , m_clockRate(0)
+        , m_channels(0)
+        , m_ccmfir(false)
+        , m_nackpli(false)
+        , m_nack(false)
+    { }
+
+    unsigned m_type;
+    String m_encodingName;
+    unsigned m_clockRate;
+
+    // audio
+    unsigned m_channels;
+
+    // video
+    bool m_ccmfir;
+    bool m_nackpli;
+    bool m_nack;
+
+    HashMap<String, unsigned> m_parameters;
+};
+
+} // namespace WebCore
+
+#endif // ENABLE(MEDIA_STREAM)
+
+#endif // MediaPayload_h
diff --git a/Source/WebCore/platform/mediastream/PeerMediaDescription.h b/Source/WebCore/platform/mediastream/PeerMediaDescription.h
new file mode 100644
index 0000000..bc5e9c8
--- /dev/null
+++ b/Source/WebCore/platform/mediastream/PeerMediaDescription.h
@@ -0,0 +1,193 @@
+/*
+ * Copyright (C) 2015 Ericsson AB. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer
+ *    in the documentation and/or other materials provided with the
+ *    distribution.
+ * 3. Neither the name of Ericsson nor the names of its contributors
+ *    may be used to endorse or promote products derived from this
+ *    software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef PeerMediaDescription_h
+#define PeerMediaDescription_h
+
+#if ENABLE(MEDIA_STREAM)
+
+#include "IceCandidate.h"
+#include "MediaPayload.h"
+#include "RealtimeMediaSource.h"
+#include <wtf/RefCounted.h>
+#include <wtf/Vector.h>
+
+namespace WebCore {
+
+class PeerMediaDescription : public RefCounted<PeerMediaDescription> {
+public:
+    static RefPtr<PeerMediaDescription> create()
+    {
+        return adoptRef(new PeerMediaDescription());
+    }
+    virtual ~PeerMediaDescription() { }
+
+    const String& type() const { return m_type; }
+    void setType(const String& type) { m_type = type; }
+
+    unsigned short port() const { return m_port; }
+    void setPort(unsigned short port) { m_port = port; }
+
+    const String& address() const { return m_address; }
+    void setAddress(const String& address) { m_address = address; }
+
+    const String& mode() const { return m_mode; }
+    void setMode(const String& mode) { m_mode = mode; }
+
+    const Vector<RefPtr<MediaPayload>>& payloads() const { return m_payloads; }
+    void addPayload(RefPtr<MediaPayload>&& payload) { m_payloads.append(WTF::move(payload)); }
+    void setPayloads(Vector<RefPtr<MediaPayload>>&& payloads) { m_payloads = payloads; }
+    void setPayloads(const Vector<RefPtr<MediaPayload>>& payloads) { m_payloads = payloads; }
+
+    bool rtcpMux() const { return m_rtcpMux; }
+    void setRtcpMux(bool rtcpMux) { m_rtcpMux = rtcpMux; }
+
+    const String& rtcpAddress() const { return m_rtcpAddress; }
+    void setRtcpAddress(const String& rtcpAddress) { m_rtcpAddress = rtcpAddress; }
+
+    unsigned short rtcpPort() const { return m_rtcpPort; }
+    void setRtcpPort(unsigned short rtcpPort) { m_rtcpPort = rtcpPort; }
+
+    const String& mediaStreamId() const { return m_mediaStreamId; }
+    void setMediaStreamId(const String& mediaStreamId) { m_mediaStreamId = mediaStreamId; }
+
+    const String& mediaStreamTrackId() const { return m_mediaStreamTrackId; }
+    void setMediaStreamTrackId(const String& mediaStreamTrackId) { m_mediaStreamTrackId = mediaStreamTrackId; }
+
+    const String& dtlsSetup() const { return m_dtlsSetup; }
+    void setDtlsSetup(const String& dtlsSetup) { m_dtlsSetup = dtlsSetup; }
+
+    const String& dtlsFingerprintHashFunction() const { return m_dtlsFingerprintHashFunction; }
+    void setDtlsFingerprintHashFunction(const String& dtlsFingerprintHashFunction) { m_dtlsFingerprintHashFunction = dtlsFingerprintHashFunction; }
+
+    const String& dtlsFingerprint() const { return m_dtlsFingerprint; }
+    void setDtlsFingerprint(const String& dtlsFingerprint) { m_dtlsFingerprint = dtlsFingerprint; }
+
+    const String& cname() const { return m_cname; }
+    void setCname(const String& cname) { m_cname = cname; }
+
+    const Vector<unsigned>& ssrcs() const { return m_ssrcs; }
+    void addSsrc(unsigned ssrc) { m_ssrcs.append(ssrc); }
+    void clearSsrcs() { m_ssrcs.clear(); }
+
+    const String& iceUfrag() const { return m_iceUfrag; }
+    void setIceUfrag(const String& iceUfrag) { m_iceUfrag = iceUfrag; }
+
+    const String& icePassword() const { return m_icePassword; }
+    void setIcePassword(const String& icePassword) { m_icePassword = icePassword; }
+
+    const Vector<RefPtr<IceCandidate>>& iceCandidates() const { return m_iceCandidates; }
+    void addIceCandidate(RefPtr<IceCandidate>&& candidate) { m_iceCandidates.append(WTF::move(candidate)); }
+
+    bool iceCandidateGatheringDone() const { return m_iceCandidateGatheringDone; }
+    void setIceCandidateGatheringDone(bool iceCandidateGatheringDone) { m_iceCandidateGatheringDone = iceCandidateGatheringDone; }
+
+    RealtimeMediaSource* source() const { return m_source.get(); }
+    void setSource(RefPtr<RealtimeMediaSource>&& source) { m_source = source; }
+
+    RefPtr<PeerMediaDescription> clone() const
+    {
+        RefPtr<PeerMediaDescription> copy = create();
+
+        copy->m_type = String(m_type);
+        copy->m_port = m_port;
+        copy->m_address = String(m_address);
+        copy->m_mode = String(m_mode);
+
+        for (auto& payload : m_payloads)
+            copy->m_payloads.append(payload->clone());
+
+        copy->m_rtcpMux = m_rtcpMux;
+        copy->m_rtcpAddress = String(m_rtcpAddress);
+        copy->m_rtcpPort = m_rtcpPort;
+
+        copy->m_mediaStreamId = String(m_mediaStreamId);
+        copy->m_mediaStreamTrackId = String(m_mediaStreamTrackId);
+
+        copy->m_dtlsSetup = String(m_dtlsSetup);
+        copy->m_dtlsFingerprintHashFunction = String(m_dtlsFingerprintHashFunction);
+        copy->m_dtlsFingerprint = String(m_dtlsFingerprint);
+
+        for (auto ssrc : m_ssrcs)
+            copy->m_ssrcs.append(ssrc);
+
+        copy->m_cname = String(m_cname);
+
+        copy->m_iceUfrag = String(m_iceUfrag);
+        copy->m_icePassword = String(m_icePassword);
+
+        for (auto& candidate : m_iceCandidates)
+            copy->m_iceCandidates.append(candidate->clone());
+
+        return copy;
+    }
+
+private:
+    PeerMediaDescription()
+        : m_port(0)
+        , m_rtcpMux(false)
+        , m_iceCandidateGatheringDone(false)
+        , m_source(nullptr)
+    { }
+
+    String m_type;
+    unsigned short m_port;
+    String m_address;
+    String m_mode;
+
+    Vector<RefPtr<MediaPayload>> m_payloads;
+
+    bool m_rtcpMux;
+    String m_rtcpAddress;
+    unsigned short m_rtcpPort;
+
+    String m_mediaStreamId;
+    String m_mediaStreamTrackId;
+
+    String m_dtlsSetup;
+    String m_dtlsFingerprintHashFunction;
+    String m_dtlsFingerprint;
+
+    Vector<unsigned> m_ssrcs;
+    String m_cname;
+
+    String m_iceUfrag;
+    String m_icePassword;
+    Vector<RefPtr<IceCandidate>> m_iceCandidates;
+    bool m_iceCandidateGatheringDone;
+
+    RefPtr<RealtimeMediaSource> m_source;
+};
+
+} // namespace WebCore
+
+#endif // ENABLE(MEDIA_STREAM)
+
+#endif // PeerMediaDescription_h
diff --git a/Source/WebCore/platform/mediastream/RTCConfigurationPrivate.h b/Source/WebCore/platform/mediastream/RTCConfigurationPrivate.h
deleted file mode 100644
index 8a1354c..0000000
--- a/Source/WebCore/platform/mediastream/RTCConfigurationPrivate.h
+++ /dev/null
@@ -1,80 +0,0 @@
-/*
- * Copyright (C) 2014 Apple Inc. All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- *
- * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS'' AND ANY
- * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
- * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
- * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
- * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
- * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
- * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
- * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
- * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-#ifndef RTCConfigurationPrivate_h
-#define RTCConfigurationPrivate_h
-
-#if ENABLE(MEDIA_STREAM)
-
-#include "RTCIceServerPrivate.h"
-#include <wtf/PassRefPtr.h>
-#include <wtf/RefCounted.h>
-#include <wtf/Vector.h>
-#include <wtf/text/WTFString.h>
-
-namespace WebCore {
-
-class RTCConfigurationPrivate : public RefCounted<RTCConfigurationPrivate> {
-public:
-    static PassRefPtr<RTCConfigurationPrivate> create() { return adoptRef(new RTCConfigurationPrivate()); }
-    virtual ~RTCConfigurationPrivate() { }
-
-    void appendServer(PassRefPtr<RTCIceServerPrivate> server) { m_privateServers.append(server); }
-    size_t numberOfServers() { return m_privateServers.size(); }
-    RTCIceServerPrivate* server(size_t index) { return m_privateServers[index].get(); }
-
-    const String& iceTransports() const { return m_iceTransports; }
-    void setIceTransports(const String& iceTransports)
-    {
-        if (iceTransports == "none" || iceTransports == "relay" || iceTransports == "all")
-            m_iceTransports = iceTransports;
-    }
-
-    const String& requestIdentity() const { return m_requestIdentity; }
-    void setRequestIdentity(const String& requestIdentity)
-    {
-        if (requestIdentity == "yes" || requestIdentity == "no" || requestIdentity == "ifconfigured")
-            m_requestIdentity = requestIdentity;
-    }
-
-    Vector<RefPtr<RTCIceServerPrivate>> iceServers() const { return m_privateServers; }
-
-private:
-    RTCConfigurationPrivate()
-        : m_iceTransports("all")
-        , m_requestIdentity("ifconfigured")
-    {
-    }
-
-    Vector<RefPtr<RTCIceServerPrivate>> m_privateServers;
-    String m_iceTransports;
-    String m_requestIdentity;
-};
-
-} // namespace WebCore
-
-#endif // ENABLE(MEDIA_STREAM)
-
-#endif // RTCConfigurationPrivate_h
diff --git a/Source/WebCore/platform/mediastream/RTCIceServerPrivate.h b/Source/WebCore/platform/mediastream/RTCIceServerPrivate.h
deleted file mode 100644
index 9bd8019..0000000
--- a/Source/WebCore/platform/mediastream/RTCIceServerPrivate.h
+++ /dev/null
@@ -1,67 +0,0 @@
-/*
- * Copyright (C) 2014 Apple Inc. All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- *
- * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS'' AND ANY
- * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
- * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
- * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
- * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
- * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
- * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
- * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
- * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. 
- */
-
-#ifndef RTCIceServerPrivate_h
-#define RTCIceServerPrivate_h
-
-#if ENABLE(MEDIA_STREAM)
-
-#include <wtf/PassRefPtr.h>
-#include <wtf/RefCounted.h>
-#include <wtf/Vector.h>
-#include <wtf/text/WTFString.h>
-
-namespace WebCore {
-
-class RTCIceServerPrivate : public RefCounted<RTCIceServerPrivate> {
-public:
-    static PassRefPtr<RTCIceServerPrivate> create(const Vector<String>& urls, const String& credential, const String& username)
-    {
-        return adoptRef(new RTCIceServerPrivate(urls, credential, username));
-    }
-    virtual ~RTCIceServerPrivate() { }
-
-    const Vector<String>& urls() { return m_urls; }
-    const String& credential() { return m_credential; }
-    const String& username() { return m_username; }
-
-private:
-    RTCIceServerPrivate(const Vector<String>& urls, const String& credential, const String& username)
-        : m_urls(urls)
-        , m_credential(credential)
-        , m_username(username)
-    {
-    }
-
-    Vector<String> m_urls;
-    String m_credential;
-    String m_username;
-};
-
-} // namespace WebCore
-
-#endif // ENABLE(MEDIA_STREAM)
-
-#endif // RTCIceServerPrivate_h
diff --git a/Source/WebCore/platform/mediastream/RTCOfferAnswerOptionsPrivate.h b/Source/WebCore/platform/mediastream/RTCOfferAnswerOptionsPrivate.h
deleted file mode 100644
index 21e283e..0000000
--- a/Source/WebCore/platform/mediastream/RTCOfferAnswerOptionsPrivate.h
+++ /dev/null
@@ -1,108 +0,0 @@
-/*
- * Copyright (C) 2014 Apple Inc. All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- *
- * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS'' AND ANY
- * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
- * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
- * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
- * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
- * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
- * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
- * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
- * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-#ifndef RTCOfferAnswerOptionsPrivate_h
-#define RTCOfferAnswerOptionsPrivate_h
-
-#if ENABLE(MEDIA_STREAM)
-
-#include <wtf/PassRefPtr.h>
-#include <wtf/RefCounted.h>
-#include <wtf/text/WTFString.h>
-
-namespace WebCore {
-
-static bool validateRequestIdentity(const String& value)
-{
-    return value == "yes" || value == "no" || value == "ifconfigured";
-}
-
-class RTCOfferAnswerOptionsPrivate : public RefCounted<RTCOfferAnswerOptionsPrivate> {
-public:
-    static PassRefPtr<RTCOfferAnswerOptionsPrivate> create()
-    {
-        return adoptRef(new RTCOfferAnswerOptionsPrivate());
-    }
-
-    const String& requestIdentity() const { return m_requestIdentity; }
-    void setRequestIdentity(const String& requestIdentity)
-    {
-        if (!validateRequestIdentity(requestIdentity))
-            return;
-
-        m_requestIdentity = requestIdentity;
-    }
-
-    virtual ~RTCOfferAnswerOptionsPrivate() { }
-
-protected:
-    RTCOfferAnswerOptionsPrivate()
-        : m_requestIdentity("ifconfigured")
-    {
-    }
-
-private:
-    String m_requestIdentity;
-};
-
-class RTCOfferOptionsPrivate : public RTCOfferAnswerOptionsPrivate {
-public:
-    static PassRefPtr<RTCOfferOptionsPrivate> create()
-    {
-        return adoptRef(new RTCOfferOptionsPrivate());
-    }
-
-    int64_t offerToReceiveVideo() const { return m_offerToReceiveVideo; }
-    void setOfferToReceiveVideo(int64_t offerToReceiveVideo) { m_offerToReceiveVideo = offerToReceiveVideo; }
-    int64_t offerToReceiveAudio() const { return m_offerToReceiveAudio; }
-    void setOfferToReceiveAudio(int64_t offerToReceiveAudio) { m_offerToReceiveAudio = offerToReceiveAudio; }
-    bool voiceActivityDetection() const { return m_voiceActivityDetection; }
-    void setVoiceActivityDetection(bool voiceActivityDetection) { m_voiceActivityDetection = voiceActivityDetection; }
-    bool iceRestart() const { return m_iceRestart; }
-    void setIceRestart(bool iceRestart) { m_iceRestart = iceRestart; }
-
-    virtual ~RTCOfferOptionsPrivate() { }
-
-private:
-    RTCOfferOptionsPrivate()
-        : RTCOfferAnswerOptionsPrivate()
-        , m_offerToReceiveVideo(0)
-        , m_offerToReceiveAudio(0)
-        , m_voiceActivityDetection(true)
-        , m_iceRestart(false)
-    {
-    }
-
-    int64_t m_offerToReceiveVideo;
-    int64_t m_offerToReceiveAudio;
-    bool m_voiceActivityDetection;
-    bool m_iceRestart;
-};
-
-} // namespace WebCore
-
-#endif // ENABLE(MEDIA_STREAM)
-
-#endif // RTCOfferAnswerOptionsPrivate_h
diff --git a/Source/WebCore/platform/mediastream/SDPProcessorScriptResource.cpp b/Source/WebCore/platform/mediastream/SDPProcessorScriptResource.cpp
new file mode 100644
index 0000000..a62f806
--- /dev/null
+++ b/Source/WebCore/platform/mediastream/SDPProcessorScriptResource.cpp
@@ -0,0 +1,51 @@
+/*
+ * Copyright (C) 2015 Ericsson AB. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer
+ *    in the documentation and/or other materials provided with the
+ *    distribution.
+ * 3. Neither the name of Ericsson nor the names of its contributors
+ *    may be used to endorse or promote products derived from this
+ *    software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include "config.h"
+
+#if ENABLE(MEDIA_STREAM)
+#include "SDPProcessorScriptResource.h"
+
+namespace WebCore {
+
+namespace SDPProcessorScriptResource {
+
+String scriptString()
+{
+    return emptyString();
+}
+
+} // namespace SDPProcessorScriptResource
+
+} // namespace WebCore
+
+#endif // ENABLE(MEDIA_STREAM)
+
+#endif // SDPProcessorScriptResource_h
diff --git a/Source/WebCore/platform/mediastream/SDPProcessorScriptResource.h b/Source/WebCore/platform/mediastream/SDPProcessorScriptResource.h
new file mode 100644
index 0000000..11f9ae0
--- /dev/null
+++ b/Source/WebCore/platform/mediastream/SDPProcessorScriptResource.h
@@ -0,0 +1,50 @@
+/*
+ * Copyright (C) 2015 Ericsson AB. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer
+ *    in the documentation and/or other materials provided with the
+ *    distribution.
+ * 3. Neither the name of Ericsson nor the names of its contributors
+ *    may be used to endorse or promote products derived from this
+ *    software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef SDPProcessorScriptResource_h
+#define SDPProcessorScriptResource_h
+
+#if ENABLE(MEDIA_STREAM)
+
+#include <wtf/text/WTFString.h>
+
+namespace WebCore {
+
+namespace SDPProcessorScriptResource {
+
+String scriptString();
+
+} // namespace SDPProcessorScriptResource
+
+} // namespace WebCore
+
+#endif // ENABLE(MEDIA_STREAM)
+
+#endif // SDPProcessorScriptResource_h
diff --git a/Source/WebCore/platform/mediastream/glib/SDPProcessorScriptResourceGLib.cpp b/Source/WebCore/platform/mediastream/glib/SDPProcessorScriptResourceGLib.cpp
new file mode 100644
index 0000000..d224d6b
--- /dev/null
+++ b/Source/WebCore/platform/mediastream/glib/SDPProcessorScriptResourceGLib.cpp
@@ -0,0 +1,51 @@
+/*
+ * Copyright (C) 2015 Ericsson AB. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer
+ *    in the documentation and/or other materials provided with the
+ *    distribution.
+ * 3. Neither the name of Ericsson nor the names of its contributors
+ *    may be used to endorse or promote products derived from this
+ *    software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include "config.h"
+
+#if ENABLE(MEDIA_STREAM)
+#include "SDPProcessorScriptResource.h"
+
+#include "SDPProcessorScripts.h"
+
+namespace WebCore {
+
+namespace SDPProcessorScriptResource {
+
+String scriptString()
+{
+    return String(sdpJavaScript);
+}
+
+} // namespace SDPProcessorScriptResource
+
+} // namespace WebCore
+
+#endif // ENABLE(MEDIA_STREAM)
diff --git a/Source/WebCore/platform/mediastream/openwebrtc/MediaEndpointOwr.cpp b/Source/WebCore/platform/mediastream/openwebrtc/MediaEndpointOwr.cpp
new file mode 100644
index 0000000..f1b0277
--- /dev/null
+++ b/Source/WebCore/platform/mediastream/openwebrtc/MediaEndpointOwr.cpp
@@ -0,0 +1,515 @@
+/*
+ * Copyright (C) 2015 Ericsson AB. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer
+ *    in the documentation and/or other materials provided with the
+ *    distribution.
+ * 3. Neither the name of Ericsson nor the names of its contributors
+ *    may be used to endorse or promote products derived from this
+ *    software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include "config.h"
+
+#if ENABLE(MEDIA_STREAM)
+#include "MediaEndpointOwr.h"
+
+#include "MediaEndpointConfiguration.h"
+#include "MediaPayload.h"
+#include "OpenWebRTCUtilities.h"
+#include "RealtimeMediaSourceOwr.h"
+#include <owr/owr.h>
+#include <owr/owr_audio_payload.h>
+#include <owr/owr_crypto_utils.h>
+#include <owr/owr_video_payload.h>
+#include <wtf/text/CString.h>
+
+namespace WebCore {
+
+static void gotCandidate(OwrSession*, OwrCandidate*, MediaEndpointOwr*);
+static void candidateGatheringDone(OwrSession*, MediaEndpointOwr*);
+static void gotIncomingSource(OwrMediaSession*, OwrMediaSource*, MediaEndpointOwr*);
+
+static const Vector<String> candidateTypes = { "host", "srflx", "prflx", "relay" };
+static const Vector<String> candidateTcpTypes = { "", "active", "passive", "so" };
+static const Vector<String> codecTypes = { "NONE", "PCMU", "PCMA", "OPUS", "H264", "VP8" };
+
+static std::unique_ptr<MediaEndpoint> createMediaEndpointOwr(MediaEndpointClient* client)
+{
+    return std::unique_ptr<MediaEndpoint>(new MediaEndpointOwr(client));
+}
+
+CreateMediaEndpoint MediaEndpoint::create = createMediaEndpointOwr;
+
+MediaEndpointOwr::MediaEndpointOwr(MediaEndpointClient* client)
+    : m_transportAgent(nullptr)
+    , m_client(client)
+    , m_numberOfReceivePreparedSessions(0)
+    , m_numberOfSendPreparedSessions(0)
+    , m_dtlsPrivateKey(nullptr)
+    , m_dtlsCertificate(nullptr)
+{
+    initializeOpenWebRTC();
+}
+
+MediaEndpointOwr::~MediaEndpointOwr()
+{
+    stop();
+
+    g_free(m_dtlsPrivateKey);
+    g_free(m_dtlsCertificate);
+}
+
+void MediaEndpointOwr::setConfiguration(RefPtr<MediaEndpointInit>&& configuration)
+{
+    m_configuration = configuration;
+}
+
+static void cryptoDataCallback(gchar* privateKey, gchar* certificate, gchar* fingerprint, gchar* fingerprintFunction, gpointer data)
+{
+    MediaEndpointOwr* mediaEndpoint = (MediaEndpointOwr*) data;
+    mediaEndpoint->dispatchDtlsFingerprint(g_strdup(privateKey), g_strdup(certificate), String(fingerprint), String(fingerprintFunction));
+}
+
+void MediaEndpointOwr::getDtlsFingerprint()
+{
+    owr_crypto_create_crypto_data(cryptoDataCallback, this);
+}
+
+Vector<RefPtr<MediaPayload>> MediaEndpointOwr::getDefaultAudioPayloads()
+{
+    Vector<RefPtr<MediaPayload>> payloads;
+
+    RefPtr<MediaPayload> payload = MediaPayload::create();
+    payload->setType(111);
+    payload->setEncodingName("OPUS");
+    payload->setClockRate(48000);
+    payload->setChannels(2);
+    payloads.append(payload);
+
+    payload = MediaPayload::create();
+    payload->setType(8);
+    payload->setEncodingName("PCMA");
+    payload->setClockRate(8000);
+    payload->setChannels(1);
+    payloads.append(payload);
+
+    payload = MediaPayload::create();
+    payload->setType(0);
+    payload->setEncodingName("PCMU");
+    payload->setClockRate(8000);
+    payload->setChannels(1);
+    payloads.append(payload);
+
+    return payloads;
+}
+
+Vector<RefPtr<MediaPayload>> MediaEndpointOwr::getDefaultVideoPayloads()
+{
+    Vector<RefPtr<MediaPayload>> payloads;
+
+    // RefPtr<MediaPayload> payload = MediaPayload::create();
+    // payload->setType(103);
+    // payload->setEncodingName("H264");
+    // payload->setClockRate(90000);
+    // payload->setCcmfir(true);
+    // payload->setNackpli(true);
+    // payload->addParameter("packetizationMode", 1);
+    // payloads.append(payload);
+
+    RefPtr<MediaPayload> payload = MediaPayload::create();
+    payload->setType(100);
+    payload->setEncodingName("VP8");
+    payload->setClockRate(90000);
+    payload->setCcmfir(true);
+    payload->setNackpli(true);
+    payload->setNack(true);
+    payloads.append(payload);
+
+    payload = MediaPayload::create();
+    payload->setType(120);
+    payload->setEncodingName("RTX");
+    payload->setClockRate(90000);
+    payload->addParameter("apt", 100);
+    payload->addParameter("rtxTime", 200);
+    payloads.append(payload);
+
+    return payloads;
+}
+
+MediaEndpointPrepareResult MediaEndpointOwr::prepareToReceive(MediaEndpointConfiguration* configuration, bool isInitiator)
+{
+    Vector<SessionConfig> sessionConfigs;
+    for (unsigned i = m_sessions.size(); i < configuration->mediaDescriptions().size(); ++i) {
+        SessionConfig config;
+        config.type = SessionTypeMedia;
+        config.isDtlsClient = configuration->mediaDescriptions()[i]->dtlsSetup() == "active";
+        sessionConfigs.append(WTF::move(config));
+    }
+
+    ensureTransportAgentAndSessions(isInitiator, sessionConfigs);
+
+    // Prepare the new sessions.
+    for (unsigned i = m_numberOfReceivePreparedSessions; i < m_sessions.size(); ++i) {
+        prepareMediaSession(OWR_MEDIA_SESSION(m_sessions[i]), configuration->mediaDescriptions()[i].get(), isInitiator);
+        owr_transport_agent_add_session(m_transportAgent, m_sessions[i]);
+    }
+
+    m_numberOfReceivePreparedSessions = m_sessions.size();
+
+    return MediaEndpointPrepareResult::Success;
+}
+
+static RefPtr<MediaPayload> findRtxPayload(Vector<RefPtr<MediaPayload>> payloads, unsigned apt)
+{
+    for (auto& payload : payloads) {
+        if (payload->encodingName().upper() == "RTX" && payload->parameters().contains("apt")
+            && (payload->parameters().get("apt") == apt))
+            return payload;
+    }
+    return nullptr;
+}
+
+MediaEndpointPrepareResult MediaEndpointOwr::prepareToSend(MediaEndpointConfiguration* configuration, bool isInitiator)
+{
+    Vector<SessionConfig> sessionConfigs;
+    for (unsigned i = m_sessions.size(); i < configuration->mediaDescriptions().size(); ++i) {
+        SessionConfig config;
+        config.type = SessionTypeMedia;
+        config.isDtlsClient = configuration->mediaDescriptions()[i]->dtlsSetup() != "active";
+        sessionConfigs.append(WTF::move(config));
+    }
+
+    ensureTransportAgentAndSessions(isInitiator, sessionConfigs);
+
+    for (unsigned i = 0; i < m_sessions.size(); ++i) {
+        if (i >= configuration->mediaDescriptions().size())
+            printf("prepareToSend: BAD missing configuration element for %d\n", i);
+
+        OwrSession* session = m_sessions[i];
+        PeerMediaDescription& mdesc = *configuration->mediaDescriptions()[i];
+
+        if (mdesc.type() == "audio" || mdesc.type() == "video")
+            g_object_set(session, "rtcp-mux", mdesc.rtcpMux(), nullptr);
+
+        if (mdesc.iceCandidates().size()) {
+            for (auto& candidate : mdesc.iceCandidates())
+                internalAddRemoteCandidate(session, *candidate, mdesc.iceUfrag(), mdesc.icePassword());
+        }
+
+        if (i < m_numberOfSendPreparedSessions)
+            continue;
+
+        if (!mdesc.source())
+            continue;
+
+        MediaPayload* payload = nullptr;
+        for (auto& p : mdesc.payloads()) {
+            if (p->encodingName().upper() != "RTX") {
+                payload = p.get();
+                break;
+            }
+        }
+
+        if (!payload) {
+            printf("prepareToSend: no payloads\n");
+            return MediaEndpointPrepareResult::Failed;
+        }
+
+        RefPtr<MediaPayload> rtxPayload = findRtxPayload(mdesc.payloads(), payload->type());
+        RealtimeMediaSourceOwr* source = static_cast<RealtimeMediaSourceOwr*>(mdesc.source());
+
+        ASSERT(codecTypes.find(payload->encodingName().upper()) != notFound);
+        OwrCodecType codecType = static_cast<OwrCodecType>(codecTypes.find(payload->encodingName().upper()));
+
+        OwrPayload* sendPayload;
+        if (mdesc.type() == "audio")
+            sendPayload = owr_audio_payload_new(codecType, payload->type(), payload->clockRate(), payload->channels());
+        else {
+            sendPayload = owr_video_payload_new(codecType, payload->type(), payload->clockRate(), payload->ccmfir(), payload->nackpli());
+            g_object_set(sendPayload, "rtx-payload-type", rtxPayload ? rtxPayload->type() : -1,
+                "rtx-time", rtxPayload && rtxPayload->parameters().contains("rtxTime") ? rtxPayload->parameters().get("rtxTime") : 0, nullptr);
+        }
+
+        owr_media_session_set_send_payload(OWR_MEDIA_SESSION(session), sendPayload);
+        owr_media_session_set_send_source(OWR_MEDIA_SESSION(session), source->mediaSource());
+
+        m_numberOfSendPreparedSessions = i + 1;
+    }
+
+    return MediaEndpointPrepareResult::Success;
+}
+
+void MediaEndpointOwr::addRemoteCandidate(IceCandidate& candidate, unsigned mdescIndex, const String& ufrag, const String& password)
+{
+    internalAddRemoteCandidate(m_sessions[mdescIndex], candidate, ufrag, password);
+}
+
+void MediaEndpointOwr::replaceSendSource(RealtimeMediaSource& newSource, unsigned mdescIndex)
+{
+    RealtimeMediaSourceOwr& owrSource = static_cast<RealtimeMediaSourceOwr&>(newSource);
+    // FIXME: An OWR bug prevents this from succeeding
+    owr_media_session_set_send_source(OWR_MEDIA_SESSION(m_sessions[mdescIndex]), owrSource.mediaSource());
+}
+
+void MediaEndpointOwr::stop()
+{
+    if (!m_transportAgent)
+        return;
+
+    for (auto session : m_sessions)
+        owr_media_session_set_send_source(OWR_MEDIA_SESSION(session), nullptr);
+
+    g_object_unref(m_transportAgent);
+    m_transportAgent = nullptr;
+}
+
+unsigned MediaEndpointOwr::sessionIndex(OwrSession* session) const
+{
+    unsigned index = m_sessions.find(session);
+    ASSERT(index != notFound);
+    return index;
+}
+
+void MediaEndpointOwr::dispatchNewIceCandidate(unsigned sessionIndex, RefPtr<IceCandidate>&& iceCandidate)
+{
+    m_client->gotIceCandidate(sessionIndex, WTF::move(iceCandidate));
+}
+
+void MediaEndpointOwr::dispatchGatheringDone(unsigned sessionIndex)
+{
+    m_client->doneGatheringCandidates(sessionIndex);
+}
+
+void MediaEndpointOwr::dispatchDtlsFingerprint(gchar* privateKey, gchar* certificate, const String& fingerprint, const String& fingerprintFunction)
+{
+    m_dtlsPrivateKey = privateKey;
+    m_dtlsCertificate = certificate;
+
+    m_client->gotDtlsFingerprint(fingerprint, fingerprintFunction);
+}
+
+void MediaEndpointOwr::dispatchRemoteSource(unsigned sessionIndex, RefPtr<RealtimeMediaSource>&& source)
+{
+    m_client->gotRemoteSource(sessionIndex, WTF::move(source));
+}
+
+void MediaEndpointOwr::prepareSession(OwrSession* session, PeerMediaDescription* mediaDescription)
+{
+    g_object_set_data_full(G_OBJECT(session), "ice-ufrag", g_strdup(mediaDescription->iceUfrag().ascii().data()), g_free);
+    g_object_set_data_full(G_OBJECT(session), "ice-password", g_strdup(mediaDescription->icePassword().ascii().data()), g_free);
+
+    g_signal_connect(session, "on-new-candidate", G_CALLBACK(gotCandidate), this);
+    g_signal_connect(session, "on-candidate-gathering-done", G_CALLBACK(candidateGatheringDone), this);
+}
+
+void MediaEndpointOwr::prepareMediaSession(OwrMediaSession* mediaSession, PeerMediaDescription* mediaDescription, bool isInitiator)
+{
+    prepareSession(OWR_SESSION(mediaSession), mediaDescription);
+
+    bool useRtpMux = !isInitiator && mediaDescription->rtcpMux();
+    g_object_set(mediaSession, "rtcp-mux", useRtpMux, nullptr);
+
+    if (!mediaDescription->cname().isEmpty() && mediaDescription->ssrcs().size()) {
+        g_object_set(mediaSession, "cname", mediaDescription->cname().ascii().data(),
+            "send-ssrc", mediaDescription->ssrcs()[0],
+            nullptr);
+    }
+
+    g_signal_connect(mediaSession, "on-incoming-source", G_CALLBACK(gotIncomingSource), this);
+
+    for (auto& payload : mediaDescription->payloads()) {
+        if (payload->encodingName().upper() == "RTX")
+            continue;
+
+        RefPtr<MediaPayload> rtxPayload = findRtxPayload(mediaDescription->payloads(), payload->type());
+
+        ASSERT(codecTypes.find(payload->encodingName()) != notFound);
+        OwrCodecType codecType = static_cast<OwrCodecType>(codecTypes.find(payload->encodingName()));
+
+        OwrPayload* receivePayload;
+        if (mediaDescription->type() == "audio")
+            receivePayload = owr_audio_payload_new(codecType, payload->type(), payload->clockRate(), payload->channels());
+        else {
+            receivePayload = owr_video_payload_new(codecType, payload->type(), payload->clockRate(), payload->ccmfir(), payload->nackpli());
+            g_object_set(receivePayload, "rtx-payload-type", rtxPayload ? rtxPayload->type() : -1,
+                "rtx-time", rtxPayload && rtxPayload->parameters().contains("rtxTime") ? rtxPayload->parameters().get("rtxTime") : 0, nullptr);
+        }
+
+        owr_media_session_add_receive_payload(mediaSession, receivePayload);
+    }
+}
+
+void MediaEndpointOwr::ensureTransportAgentAndSessions(bool isInitiator, const Vector<SessionConfig>& sessionConfigs)
+{
+    ASSERT(m_dtlsPrivateKey);
+    ASSERT(m_dtlsCertificate);
+
+    if (!m_transportAgent) {
+        m_transportAgent = owr_transport_agent_new(false);
+
+        for (auto& server : m_configuration->iceServers()) {
+            // FIXME: parse url type and port
+            owr_transport_agent_add_helper_server(m_transportAgent, OWR_HELPER_SERVER_TYPE_STUN,
+                server->urls()[0].ascii().data(), 3478, nullptr, nullptr);
+        }
+    }
+
+    g_object_set(m_transportAgent, "ice-controlling-mode", isInitiator, nullptr);
+
+    for (auto& config : sessionConfigs) {
+        OwrSession* session = OWR_SESSION(owr_media_session_new(config.isDtlsClient));
+        g_object_set(session, "dtls-certificate", m_dtlsCertificate,
+            "dtls-key", m_dtlsPrivateKey,
+            nullptr);
+
+        m_sessions.append(session);
+    }
+}
+
+void MediaEndpointOwr::internalAddRemoteCandidate(OwrSession* session, IceCandidate& candidate, const String& ufrag, const String& password)
+{
+    gboolean rtcpMux;
+    g_object_get(session, "rtcp-mux", &rtcpMux, nullptr);
+
+    if (rtcpMux && candidate.componentId() == OWR_COMPONENT_TYPE_RTCP)
+        return;
+
+    ASSERT(candidateTypes.find(candidate.type()) != notFound);
+    printf("ASSERT: %d\n", (candidateTypes.find(candidate.type()) != notFound));
+
+    OwrCandidateType candidateType = static_cast<OwrCandidateType>(candidateTypes.find(candidate.type()));
+    OwrComponentType componentId = static_cast<OwrComponentType>(candidate.componentId());
+    OwrTransportType transportType;
+
+    if (candidate.transport().upper() == "UDP")
+        transportType = OWR_TRANSPORT_TYPE_UDP;
+    else {
+        ASSERT(candidateTcpTypes.find(candidate.tcpType()) != notFound);
+        printf("ASSERT: %d\n", (candidateTcpTypes.find(candidate.tcpType()) != notFound));
+        transportType = static_cast<OwrTransportType>(candidateTcpTypes.find(candidate.tcpType()));
+    }
+
+    OwrCandidate* owrCandidate = owr_candidate_new(candidateType, componentId);
+    g_object_set(owrCandidate, "transport-type", transportType,
+        "address", candidate.address().ascii().data(),
+        "port", candidate.port(),
+        "base-address", candidate.relatedAddress().ascii().data(),
+        "base-port", candidate.relatedPort(),
+        "priority", candidate.priority(),
+        "foundation", candidate.foundation().ascii().data(),
+        "ufrag", ufrag.ascii().data(),
+        "password", password.ascii().data(),
+        nullptr);
+
+    owr_session_add_remote_candidate(session, owrCandidate);
+}
+
+static void gotCandidate(OwrSession* session, OwrCandidate* candidate, MediaEndpointOwr* mediaEndpoint)
+{
+    OwrCandidateType candidateType;
+    gchar* foundation;
+    OwrComponentType componentId;
+    OwrTransportType transportType;
+    gint priority;
+    gchar* address;
+    guint port;
+    gchar* relatedAddress;
+    guint relatedPort;
+
+    g_object_get(candidate, "type", &candidateType,
+        "foundation", &foundation,
+        "component-type", &componentId,
+        "transport-type", &transportType,
+        "priority", &priority,
+        "address", &address,
+        "port", &port,
+        "base-address", &relatedAddress,
+        "base-port", &relatedPort,
+        nullptr);
+
+    ASSERT(candidateType >= 0 && candidateType < candidateTypes.size());
+    ASSERT(transportType >= 0 && transportType < candidateTcpTypes.size());
+
+    RefPtr<IceCandidate> iceCandidate = IceCandidate::create();
+    iceCandidate->setType(candidateTypes[candidateType]);
+    iceCandidate->setFoundation(foundation);
+    iceCandidate->setComponentId(componentId);
+    iceCandidate->setPriority(priority);
+    iceCandidate->setAddress(address);
+    iceCandidate->setPort(port ? port : 9);
+
+    if (transportType == OWR_TRANSPORT_TYPE_UDP)
+        iceCandidate->setTransport("UDP");
+    else {
+        iceCandidate->setTransport("TCP");
+        iceCandidate->setTcpType(candidateTcpTypes[transportType]);
+    }
+
+    if (candidateType != OWR_CANDIDATE_TYPE_HOST) {
+        iceCandidate->setRelatedAddress(relatedAddress);
+        iceCandidate->setRelatedPort(relatedPort ? relatedPort : 9);
+    }
+
+    g_object_set(G_OBJECT(candidate), "ufrag", g_object_get_data(G_OBJECT(session), "ice-ufrag"),
+        "password", g_object_get_data(G_OBJECT(session), "ice-password"),
+        nullptr);
+
+    mediaEndpoint->dispatchNewIceCandidate(mediaEndpoint->sessionIndex(session), WTF::move(iceCandidate));
+
+    g_free(foundation);
+    g_free(address);
+    g_free(relatedAddress);
+}
+
+static void candidateGatheringDone(OwrSession* session, MediaEndpointOwr* mediaEndpoint)
+{
+    mediaEndpoint->dispatchGatheringDone(mediaEndpoint->sessionIndex(session));
+}
+
+static void gotIncomingSource(OwrMediaSession* mediaSession, OwrMediaSource* source, MediaEndpointOwr* mediaEndpoint)
+{
+    String name;
+    String id("not used");
+    OwrMediaType mediaType;
+
+    g_object_get(source, "media-type", &mediaType, nullptr);
+
+    RealtimeMediaSource::Type sourceType;
+    if (mediaType == OWR_MEDIA_TYPE_AUDIO) {
+        sourceType = RealtimeMediaSource::Audio;
+        name = "remote audio";
+    }
+    else if (mediaType == OWR_MEDIA_TYPE_VIDEO) {
+        sourceType = RealtimeMediaSource::Video;
+        name = "remote video";
+    }
+    else
+        ASSERT_NOT_REACHED();
+
+    RefPtr<RealtimeMediaSourceOwr> mediaSource = adoptRef(new RealtimeMediaSourceOwr(source, id, sourceType, name));
+    mediaEndpoint->dispatchRemoteSource(mediaEndpoint->sessionIndex(OWR_SESSION(mediaSession)), WTF::move(mediaSource));
+}
+
+} // namespace WebCore
+
+#endif // ENABLE(MEDIA_STREAM)
diff --git a/Source/WebCore/platform/mediastream/openwebrtc/MediaEndpointOwr.h b/Source/WebCore/platform/mediastream/openwebrtc/MediaEndpointOwr.h
new file mode 100644
index 0000000..17b585e
--- /dev/null
+++ b/Source/WebCore/platform/mediastream/openwebrtc/MediaEndpointOwr.h
@@ -0,0 +1,104 @@
+/*
+ * Copyright (C) 2015 Ericsson AB. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer
+ *    in the documentation and/or other materials provided with the
+ *    distribution.
+ * 3. Neither the name of Ericsson nor the names of its contributors
+ *    may be used to endorse or promote products derived from this
+ *    software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef MediaEndpointOwr_h
+#define MediaEndpointOwr_h
+
+#if ENABLE(MEDIA_STREAM)
+
+#include "MediaEndpoint.h"
+#include <owr/owr_media_session.h>
+#include <owr/owr_transport_agent.h>
+
+namespace WebCore {
+
+class PeerMediaDescription;
+class RTCConfigurationPrivate;
+
+class MediaEndpointOwr : public MediaEndpoint {
+public:
+    MediaEndpointOwr(MediaEndpointClient*);
+    ~MediaEndpointOwr();
+
+    virtual void setConfiguration(RefPtr<MediaEndpointInit>&&) override;
+
+    virtual void getDtlsFingerprint() override;
+    virtual Vector<RefPtr<MediaPayload>> getDefaultAudioPayloads() override;
+    virtual Vector<RefPtr<MediaPayload>> getDefaultVideoPayloads() override;
+
+    virtual MediaEndpointPrepareResult prepareToReceive(MediaEndpointConfiguration*, bool isInitiator) override;
+    virtual MediaEndpointPrepareResult prepareToSend(MediaEndpointConfiguration*, bool isInitiator) override;
+
+    virtual void addRemoteCandidate(IceCandidate&, unsigned mdescIndex, const String& ufrag, const String& password) override;
+
+    virtual void replaceSendSource(RealtimeMediaSource&, unsigned mdescIndex) override;
+
+    virtual void stop() override;
+
+    unsigned sessionIndex(OwrSession*) const;
+
+    void dispatchNewIceCandidate(unsigned sessionIndex, RefPtr<IceCandidate>&&);
+    void dispatchGatheringDone(unsigned sessionIndex);
+    void dispatchDtlsFingerprint(gchar* privateKey, gchar* certificate, const String& fingerprint, const String& fingerprintFunction);
+    void dispatchRemoteSource(unsigned sessionIndex, RefPtr<RealtimeMediaSource>&&);
+
+private:
+    enum SessionType { SessionTypeMedia };
+
+    struct SessionConfig {
+        SessionType type;
+        bool isDtlsClient;
+    };
+
+    void prepareSession(OwrSession*, PeerMediaDescription*);
+    void prepareMediaSession(OwrMediaSession*, PeerMediaDescription*, bool isInitiator);
+
+    void ensureTransportAgentAndSessions(bool isInitiator, const Vector<SessionConfig>& sessionConfigs);
+    void internalAddRemoteCandidate(OwrSession*, IceCandidate&, const String& ufrag, const String& password);
+
+    RefPtr<MediaEndpointInit> m_configuration;
+
+    OwrTransportAgent* m_transportAgent;
+    Vector<OwrSession*> m_sessions;
+
+    MediaEndpointClient* m_client;
+
+    unsigned m_numberOfReceivePreparedSessions;
+    unsigned m_numberOfSendPreparedSessions;
+
+    gchar* m_dtlsPrivateKey;
+    gchar* m_dtlsCertificate;
+};
+
+} // namespace WebCore
+
+#endif // ENABLE(MEDIA_STREAM)
+
+#endif // MediaEndpointOwr_h
diff --git a/Source/WebCore/platform/mediastream/openwebrtc/OpenWebRTCUtilities.cpp b/Source/WebCore/platform/mediastream/openwebrtc/OpenWebRTCUtilities.cpp
index e82a735..e4cfb59 100644
--- a/Source/WebCore/platform/mediastream/openwebrtc/OpenWebRTCUtilities.cpp
+++ b/Source/WebCore/platform/mediastream/openwebrtc/OpenWebRTCUtilities.cpp
@@ -44,7 +44,12 @@ namespace WebCore {
 
 void initializeOpenWebRTC()
 {
+    static bool isInitialized = false;
+    if (isInitialized)
+        return;
+
     owr_init(g_main_context_default());
+    isInitialized = true;
 }
 
 }
diff --git a/Source/WebCore/platform/mediastream/openwebrtc/RealtimeMediaSourceCenterOwr.cpp b/Source/WebCore/platform/mediastream/openwebrtc/RealtimeMediaSourceCenterOwr.cpp
index cf584ad..fe43b0c 100644
--- a/Source/WebCore/platform/mediastream/openwebrtc/RealtimeMediaSourceCenterOwr.cpp
+++ b/Source/WebCore/platform/mediastream/openwebrtc/RealtimeMediaSourceCenterOwr.cpp
@@ -43,10 +43,10 @@
 #include "OpenWebRTCUtilities.h"
 #include "RealtimeMediaSource.h"
 #include "RealtimeMediaSourceCapabilities.h"
-#include "UUID.h"
 #include <owr/owr.h>
 #include <owr/owr_local.h>
 #include <owr/owr_media_source.h>
+#include <wtf/SHA1.h>
 #include <wtf/MainThread.h>
 #include <wtf/NeverDestroyed.h>
 #include <wtf/glib/GUniquePtr.h>
@@ -72,6 +72,15 @@ static void mediaSourcesAvailableCallback(GList* sources, gpointer userData)
 RealtimeMediaSourceCenterOwr::RealtimeMediaSourceCenterOwr()
 {
     initializeOpenWebRTC();
+
+    // Temporary solution to hint about preferred device names.
+    char* envString = getenv("WEBKIT_AUDIO_SOURCE_NAMES");
+    if (envString)
+        String(envString).split(',', false, m_preferredAudioSourceNames);
+
+    envString = getenv("WEBKIT_VIDEO_SOURCE_NAMES");
+    if (envString)
+        String(envString).split(',', false, m_preferredVideoSourceNames);
 }
 
 RealtimeMediaSourceCenterOwr::~RealtimeMediaSourceCenterOwr()
@@ -108,7 +117,7 @@ void RealtimeMediaSourceCenterOwr::createMediaStream(PassRefPtr<MediaStreamCreat
     if (audioConstraints) {
         // TODO: verify constraints according to registered
         // sources. For now, unconditionally pick the first source, see bug #123345.
-        RefPtr<RealtimeMediaSource> audioSource = firstSource(RealtimeMediaSource::Audio);
+        RefPtr<RealtimeMediaSource> audioSource = selectSource(RealtimeMediaSource::Audio);
         if (audioSource) {
             audioSource->reset();
             audioSources.append(audioSource.release());
@@ -118,7 +127,7 @@ void RealtimeMediaSourceCenterOwr::createMediaStream(PassRefPtr<MediaStreamCreat
     if (videoConstraints) {
         // TODO: verify constraints according to registered
         // sources. For now, unconditionally pick the first source, see bug #123345.
-        RefPtr<RealtimeMediaSource> videoSource = firstSource(RealtimeMediaSource::Video);
+        RefPtr<RealtimeMediaSource> videoSource = selectSource(RealtimeMediaSource::Video);
         if (videoSource) {
             videoSource->reset();
             videoSources.append(videoSource.release());
@@ -160,55 +169,89 @@ bool RealtimeMediaSourceCenterOwr::getMediaStreamTrackSources(PassRefPtr<MediaSt
     return false;
 }
 
+static String getSourceId(OwrMediaSource* source)
+{
+    String idData = String::format("%p", source);
+    SHA1 digest;
+    digest.addBytes(idData.ascii());
+    return String(digest.computeHexDigest().data());
+}
+
 void RealtimeMediaSourceCenterOwr::mediaSourcesAvailable(GList* sources)
 {
     Vector<RefPtr<RealtimeMediaSource>> audioSources;
     Vector<RefPtr<RealtimeMediaSource>> videoSources;
 
+    RealtimeMediaSourceOwrMap newSourceMap;
+
     for (auto item = sources; item; item = item->next) {
         OwrMediaSource* source = OWR_MEDIA_SOURCE(item->data);
+        String id(getSourceId(source));
 
-        GUniqueOutPtr<gchar> name;
-        OwrMediaType mediaType;
-        g_object_get(source, "media-type", &mediaType, "name", &name.outPtr(), NULL);
-        String sourceName(name.get());
-        String id(createCanonicalUUIDString());
-
-        RealtimeMediaSource::Type sourceType;
-        if (mediaType & OWR_MEDIA_TYPE_AUDIO)
-            sourceType = RealtimeMediaSource::Audio;
-        else if (mediaType & OWR_MEDIA_TYPE_VIDEO)
-            sourceType = RealtimeMediaSource::Video;
+        if (m_sourceMap.contains(id))
+            newSourceMap.add(id, m_sourceMap.take(id));
         else {
-            sourceType = RealtimeMediaSource::None;
-            ASSERT_NOT_REACHED();
+            GUniqueOutPtr<gchar> name;
+            OwrMediaType mediaType;
+            g_object_get(source, "media-type", &mediaType, "name", &name.outPtr(), NULL);
+            String sourceName(name.get());
+
+            RealtimeMediaSource::Type sourceType;
+            if (mediaType & OWR_MEDIA_TYPE_AUDIO)
+                sourceType = RealtimeMediaSource::Audio;
+            else if (mediaType & OWR_MEDIA_TYPE_VIDEO)
+                sourceType = RealtimeMediaSource::Video;
+            else {
+                sourceType = RealtimeMediaSource::None;
+                ASSERT_NOT_REACHED();
+            }
+
+            newSourceMap.add(id, adoptRef(new RealtimeMediaSourceOwr(source, id, sourceType, sourceName)));
         }
+    }
 
-        RefPtr<RealtimeMediaSourceOwr> mediaSource = adoptRef(new RealtimeMediaSourceOwr(source, id, sourceType, sourceName));
-
-        RealtimeMediaSourceOwrMap::iterator sourceIterator = m_sourceMap.find(id);
-        if (sourceIterator == m_sourceMap.end())
-            m_sourceMap.add(id, mediaSource);
+    // Disconnected sources, left in m_sourceMap, will be discarded by swap
+    m_sourceMap.swap(newSourceMap);
 
-        if (mediaType & OWR_MEDIA_TYPE_AUDIO)
-            audioSources.append(mediaSource);
-        else if (mediaType & OWR_MEDIA_TYPE_VIDEO)
-            videoSources.append(mediaSource);
-    }
+    RefPtr<RealtimeMediaSource> audioSource = selectSource(RealtimeMediaSource::Audio);
+    if (audioSource)
+        audioSources.append(WTF::move(audioSource));
+    RefPtr<RealtimeMediaSource> videoSource = selectSource(RealtimeMediaSource::Video);
+    if (videoSource)
+        videoSources.append(WTF::move(videoSource));
 
     // TODO: Make sure contraints are actually validated by checking source types.
     m_client->constraintsValidated(audioSources, videoSources);
 }
 
-PassRefPtr<RealtimeMediaSource> RealtimeMediaSourceCenterOwr::firstSource(RealtimeMediaSource::Type type)
+static String getNextPreferredSourceName(Vector<String>& sourceNames)
 {
+    if (sourceNames.isEmpty())
+        return emptyString();
+
+    String name = sourceNames.first();
+    sourceNames.remove(0);
+    sourceNames.append(name);
+
+    return name;
+}
+
+PassRefPtr<RealtimeMediaSource> RealtimeMediaSourceCenterOwr::selectSource(RealtimeMediaSource::Type type)
+{
+    RefPtr<RealtimeMediaSource> selectedSource = nullptr;
+    const String& preferredSourceName = getNextPreferredSourceName(type == RealtimeMediaSource::Audio ? m_preferredAudioSourceNames : m_preferredVideoSourceNames);
+
     for (auto iter = m_sourceMap.begin(); iter != m_sourceMap.end(); ++iter) {
         RefPtr<RealtimeMediaSource> source = iter->value;
-        if (source->type() == type)
-            return source;
+        bool foundPreferred = source->name() == preferredSourceName;
+        if (source->type() == type && (!selectedSource || foundPreferred)) {
+            selectedSource = source;
+            if (foundPreferred)
+                break;
+        }
     }
 
-    return nullptr;
+    return selectedSource;
 }
 
 RefPtr<TrackSourceInfo> RealtimeMediaSourceCenterOwr::sourceWithUID(const String& UID, RealtimeMediaSource::Type, MediaConstraints*)
diff --git a/Source/WebCore/platform/mediastream/openwebrtc/RealtimeMediaSourceCenterOwr.h b/Source/WebCore/platform/mediastream/openwebrtc/RealtimeMediaSourceCenterOwr.h
index fe12146..1806005 100644
--- a/Source/WebCore/platform/mediastream/openwebrtc/RealtimeMediaSourceCenterOwr.h
+++ b/Source/WebCore/platform/mediastream/openwebrtc/RealtimeMediaSourceCenterOwr.h
@@ -64,9 +64,14 @@ class RealtimeMediaSourceCenterOwr final : public RealtimeMediaSourceCenter {
     RefPtr<TrackSourceInfo> sourceWithUID(const String&, RealtimeMediaSource::Type, MediaConstraints*) override;
 
 private:
-    PassRefPtr<RealtimeMediaSource> firstSource(RealtimeMediaSource::Type);
+    typedef HashMap<String, RefPtr<RealtimeMediaSourceOwr>> RealtimeMediaSourceOwrMap;
+
+    PassRefPtr<RealtimeMediaSource> selectSource(RealtimeMediaSource::Type);
     RealtimeMediaSourceOwrMap m_sourceMap;
     RefPtr<MediaStreamCreationClient> m_client;
+
+    Vector<String> m_preferredAudioSourceNames;
+    Vector<String> m_preferredVideoSourceNames;
 };
 
 } // namespace WebCore
diff --git a/Source/WebCore/platform/mediastream/openwebrtc/RealtimeMediaSourceOwr.h b/Source/WebCore/platform/mediastream/openwebrtc/RealtimeMediaSourceOwr.h
index cefe2d7..2d67dc5 100644
--- a/Source/WebCore/platform/mediastream/openwebrtc/RealtimeMediaSourceOwr.h
+++ b/Source/WebCore/platform/mediastream/openwebrtc/RealtimeMediaSourceOwr.h
@@ -69,8 +69,6 @@ RealtimeMediaSourceOwr(OwrMediaSource* mediaSource, const String& id, RealtimeMe
     OwrMediaSource* m_mediaSource;
 };
 
-typedef HashMap<String, RefPtr<RealtimeMediaSourceOwr>> RealtimeMediaSourceOwrMap;
-
 } // namespace WebCore
 
 #endif // ENABLE(MEDIA_STREAM) && USE(OPENWEBRTC)
diff --git a/Source/WebCore/platform/mock/MockMediaEndpoint.cpp b/Source/WebCore/platform/mock/MockMediaEndpoint.cpp
new file mode 100644
index 0000000..9cf2e9d
--- /dev/null
+++ b/Source/WebCore/platform/mock/MockMediaEndpoint.cpp
@@ -0,0 +1,168 @@
+/*
+ * Copyright (C) 2015 Ericsson AB. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer
+ *    in the documentation and/or other materials provided with the
+ *    distribution.
+ * 3. Neither the name of Ericsson nor the names of its contributors
+ *    may be used to endorse or promote products derived from this
+ *    software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include "config.h"
+
+#if ENABLE(MEDIA_STREAM)
+#include "MockMediaEndpoint.h"
+
+#include "MediaPayload.h"
+#include <wtf/MainThread.h>
+
+namespace WebCore {
+
+static const char* fingerprint = "8B:87:09:8A:5D:C2:F3:33:EF:C5:B1:F6:84:3A:3D:D6:A3:E2:9C:17:4C:E7:46:3B:1B:CE:84:98:DD:8E:AF:7B";
+static const char* fingerprintFunction = "sha-256";
+
+std::unique_ptr<MediaEndpoint> MockMediaEndpoint::create(MediaEndpointClient* client)
+{
+    return std::unique_ptr<MediaEndpoint>(new MockMediaEndpoint(client));
+}
+
+MockMediaEndpoint::MockMediaEndpoint(MediaEndpointClient* client)
+    : m_client(client)
+{
+}
+
+MockMediaEndpoint::~MockMediaEndpoint()
+{
+    stop();
+}
+
+void MockMediaEndpoint::setConfiguration(RefPtr<MediaEndpointInit>&& configuration)
+{
+    UNUSED_PARAM(configuration);
+}
+
+void MockMediaEndpoint::getDtlsFingerprint()
+{
+    callOnMainThread([this]() {
+        m_client->gotDtlsFingerprint(String(fingerprint), String(fingerprintFunction));
+    });
+}
+
+Vector<RefPtr<MediaPayload>> MockMediaEndpoint::getDefaultAudioPayloads()
+{
+    Vector<RefPtr<MediaPayload>> payloads;
+
+    RefPtr<MediaPayload> payload = MediaPayload::create();
+    payload->setType(111);
+    payload->setEncodingName("OPUS");
+    payload->setClockRate(48000);
+    payload->setChannels(2);
+    payloads.append(payload);
+
+    payload = MediaPayload::create();
+    payload->setType(8);
+    payload->setEncodingName("PCMA");
+    payload->setClockRate(8000);
+    payload->setChannels(1);
+    payloads.append(payload);
+
+    payload = MediaPayload::create();
+    payload->setType(0);
+    payload->setEncodingName("PCMU");
+    payload->setClockRate(8000);
+    payload->setChannels(1);
+    payloads.append(payload);
+
+    return payloads;
+}
+
+Vector<RefPtr<MediaPayload>> MockMediaEndpoint::getDefaultVideoPayloads()
+{
+    Vector<RefPtr<MediaPayload>> payloads;
+
+    // RefPtr<MediaPayload> payload = MediaPayload::create();
+    // payload->setType(103);
+    // payload->setEncodingName("H264");
+    // payload->setClockRate(90000);
+    // payload->setCcmfir(true);
+    // payload->setNackpli(true);
+    // payload->addParameter("packetizationMode", 1);
+    // payloads.append(payload);
+
+    RefPtr<MediaPayload> payload = MediaPayload::create();
+    payload->setType(100);
+    payload->setEncodingName("VP8");
+    payload->setClockRate(90000);
+    payload->setCcmfir(true);
+    payload->setNackpli(true);
+    payload->setNack(true);
+    payloads.append(payload);
+
+    payload = MediaPayload::create();
+    payload->setType(120);
+    payload->setEncodingName("RTX");
+    payload->setClockRate(90000);
+    payload->addParameter("apt", 100);
+    payload->addParameter("rtxTime", 200);
+    payloads.append(payload);
+
+    return payloads;
+}
+
+MediaEndpointPrepareResult MockMediaEndpoint::prepareToReceive(MediaEndpointConfiguration* configuration, bool isInitiator)
+{
+    UNUSED_PARAM(configuration);
+    UNUSED_PARAM(isInitiator);
+
+    return MediaEndpointPrepareResult::Success;
+}
+
+MediaEndpointPrepareResult MockMediaEndpoint::prepareToSend(MediaEndpointConfiguration* configuration, bool isInitiator)
+{
+    UNUSED_PARAM(configuration);
+    UNUSED_PARAM(isInitiator);
+
+    return MediaEndpointPrepareResult::Success;
+}
+
+void MockMediaEndpoint::addRemoteCandidate(IceCandidate& candidate, unsigned mdescIndex, const String& ufrag, const String& password)
+{
+    UNUSED_PARAM(candidate);
+    UNUSED_PARAM(mdescIndex);
+    UNUSED_PARAM(ufrag);
+    UNUSED_PARAM(password);
+}
+
+void MockMediaEndpoint::replaceSendSource(RealtimeMediaSource& newSource, unsigned mdescIndex)
+{
+    UNUSED_PARAM(newSource);
+    UNUSED_PARAM(mdescIndex);
+}
+
+void MockMediaEndpoint::stop()
+{
+}
+
+} // namespace WebCore
+
+#endif // ENABLE(MEDIA_STREAM)
diff --git a/Source/WebCore/platform/mock/MockMediaEndpoint.h b/Source/WebCore/platform/mock/MockMediaEndpoint.h
new file mode 100644
index 0000000..8c106aa
--- /dev/null
+++ b/Source/WebCore/platform/mock/MockMediaEndpoint.h
@@ -0,0 +1,70 @@
+/*
+ * Copyright (C) 2015 Ericsson AB. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer
+ *    in the documentation and/or other materials provided with the
+ *    distribution.
+ * 3. Neither the name of Ericsson nor the names of its contributors
+ *    may be used to endorse or promote products derived from this
+ *    software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef MockMediaEndpoint_h
+#define MockMediaEndpoint_h
+
+#if ENABLE(MEDIA_STREAM)
+
+#include "MediaEndpoint.h"
+
+namespace WebCore {
+
+class MockMediaEndpoint : public MediaEndpoint {
+public:
+    WEBCORE_EXPORT static std::unique_ptr<MediaEndpoint> create(MediaEndpointClient*);
+
+    MockMediaEndpoint(MediaEndpointClient*);
+    ~MockMediaEndpoint();
+
+    virtual void setConfiguration(RefPtr<MediaEndpointInit>&&) override;
+
+    virtual void getDtlsFingerprint() override;
+    virtual Vector<RefPtr<MediaPayload>> getDefaultAudioPayloads() override;
+    virtual Vector<RefPtr<MediaPayload>> getDefaultVideoPayloads() override;
+
+    virtual MediaEndpointPrepareResult prepareToReceive(MediaEndpointConfiguration*, bool isInitiator) override;
+    virtual MediaEndpointPrepareResult prepareToSend(MediaEndpointConfiguration*, bool isInitiator) override;
+
+    virtual void addRemoteCandidate(IceCandidate&, unsigned mdescIndex, const String& ufrag, const String& password) override;
+
+    virtual void replaceSendSource(RealtimeMediaSource&, unsigned mdescIndex) override;
+
+    virtual void stop() override;
+
+private:
+    MediaEndpointClient* m_client;
+};
+
+} // namespace WebCore
+
+#endif // ENABLE(MEDIA_STREAM)
+
+#endif // MockMediaEndpoint_h
diff --git a/Source/WebCore/testing/Internals.cpp b/Source/WebCore/testing/Internals.cpp
index 7de2f13..4ca2f92 100644
--- a/Source/WebCore/testing/Internals.cpp
+++ b/Source/WebCore/testing/Internals.cpp
@@ -168,6 +168,7 @@
 #endif
 
 #if ENABLE(MEDIA_STREAM)
+#include "MockMediaEndpoint.h"
 #include "MockRealtimeMediaSourceCenter.h"
 #include "RTCPeerConnection.h"
 #include "RTCPeerConnectionHandlerMock.h"
@@ -408,6 +409,7 @@ Internals::Internals(Document* document)
 
 #if ENABLE(MEDIA_STREAM)
     setMockMediaCaptureDevicesEnabled(true);
+    enableMockMediaEndpoint();
     enableMockRTCPeerConnectionHandler();
 #endif
 
@@ -955,6 +957,11 @@ void Internals::enableMockSpeechSynthesizer()
 #endif
 
 #if ENABLE(MEDIA_STREAM)
+void Internals::enableMockMediaEndpoint()
+{
+    MediaEndpoint::create = MockMediaEndpoint::create;
+}
+
 void Internals::enableMockRTCPeerConnectionHandler()
 {
     RTCPeerConnectionHandler::create = RTCPeerConnectionHandlerMock::create;
diff --git a/Source/WebCore/testing/Internals.h b/Source/WebCore/testing/Internals.h
index 61844a6..9541b68 100644
--- a/Source/WebCore/testing/Internals.h
+++ b/Source/WebCore/testing/Internals.h
@@ -348,6 +348,7 @@ class Internals : public RefCounted<Internals>
 #endif
 
 #if ENABLE(MEDIA_STREAM)
+    void enableMockMediaEndpoint();
     void enableMockRTCPeerConnectionHandler();
     void setMockMediaCaptureDevicesEnabled(bool);
 #endif
diff --git a/Source/cmake/FindOpenWebRTC.cmake b/Source/cmake/FindOpenWebRTC.cmake
index 2fface0..1ac85a8 100644
--- a/Source/cmake/FindOpenWebRTC.cmake
+++ b/Source/cmake/FindOpenWebRTC.cmake
@@ -30,7 +30,7 @@
 # ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 
 find_package(PkgConfig)
-pkg_check_modules(OPENWEBRTC openwebrtc-0.1 openwebrtc-gst-0.1)
+pkg_check_modules(OPENWEBRTC openwebrtc-0.3 openwebrtc-gst-0.3)
 
 set(VERSION_OK TRUE)
 if (OPENWEBRTC_VERSION)
diff --git a/Source/cmake/OptionsWPE.cmake b/Source/cmake/OptionsWPE.cmake
index 76bf664..584d673 100644
--- a/Source/cmake/OptionsWPE.cmake
+++ b/Source/cmake/OptionsWPE.cmake
@@ -130,6 +130,14 @@ if (ENABLE_VIDEO OR ENABLE_WEB_AUDIO)
     # FIXME: What about MPEGTS support? USE_GSTREAMER_MPEGTS?
 endif ()
 
+if (ENABLE_MEDIA_STREAM)
+    find_package(OpenWebRTC)
+    if (NOT OPENWEBRTC_FOUND)
+        message(FATAL_ERROR "OpenWebRTC is needed for ENABLE_MEDIA_STREAM.")
+    endif ()
+    SET_AND_EXPOSE_TO_BUILD(USE_OPENWEBRTC TRUE)
+endif ()
+
 if (ENABLE_ACCELERATED_2D_CANVAS)
     find_package(CairoGL 1.10.2 REQUIRED COMPONENTS cairo-egl)
 endif ()
