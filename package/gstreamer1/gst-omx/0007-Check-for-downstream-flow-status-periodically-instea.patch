From 23458d5a5a98c0f7fe2342ae4db1f3ec6f8676e7 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Enrique=20Oca=C3=B1a=20Gonz=C3=A1lez?= <eocanha@igalia.com>
Date: Fri, 12 Aug 2016 17:55:13 +0000
Subject: [PATCH] Check for downstream flow status periodically instead of
 waiting forever to acquire an OMX buffer

In some circumstances, a flush in the video decoder element happens
while waiting for a new OMX buffer (port 130) to feed new data to the
decoder. This flush stops the decoder streaming thread, and notifies the
decoder input thread using the drain_cond. That condition is only
meaningful inside gst_omx_video_dec_drain(), but irrelevant for the rest
of the cases (like waiting for an OMX buffer, where a deadlock happens).

This patch changes the gst_omx_port_acquire_buffer() call (which waits
forever) into gst_omx_port_acquire_buffer_timeout(). That way,
gst_omx_video_dec_handle_frame() can periodically check the downstream
status of the decoder and break the infinite wait if the decoder src pad
enters in flushing state. This breaks the deadlock.

The downside of this approach is that the waiting thread is waken each
second. This inefficient in the legitimate case, where the thread would
just wait until a buffer is available without consuming CPU.
---
 omx/gstomx.c         | 16 +++++++++++++++-
 omx/gstomx.h         |  5 ++++-
 omx/gstomxvideodec.c | 11 ++++++++++-
 3 files changed, 29 insertions(+), 3 deletions(-)

diff --git a/omx/gstomx.c b/omx/gstomx.c
index 7b64aab..1fc4f83 100644
--- a/omx/gstomx.c
+++ b/omx/gstomx.c
@@ -1231,6 +1231,13 @@ gst_omx_port_update_port_definition (GstOMXPort * port,
 GstOMXAcquireBufferReturn
 gst_omx_port_acquire_buffer (GstOMXPort * port, GstOMXBuffer ** buf)
 {
+  return gst_omx_port_acquire_buffer_timeout (port, buf, GST_CLOCK_TIME_NONE);
+}
+
+/* NOTE: Uses comp->lock and comp->messages_lock */
+GstOMXAcquireBufferReturn
+gst_omx_port_acquire_buffer_timeout (GstOMXPort * port, GstOMXBuffer ** buf, GstClockTime timeout)
+{
   GstOMXAcquireBufferReturn ret = GST_OMX_ACQUIRE_BUFFER_ERROR;
   GstOMXComponent *comp;
   OMX_ERRORTYPE err;
@@ -1337,9 +1344,16 @@ retry:
    * or the port needs to be reconfigured.
    */
   if (g_queue_is_empty (&port->pending_buffers)) {
+    gboolean wait_result;
     GST_DEBUG_OBJECT (comp->parent, "Queue of %s port %u is empty",
         comp->name, port->index);
-    gst_omx_component_wait_message (comp, GST_CLOCK_TIME_NONE);
+    wait_result = gst_omx_component_wait_message (comp, timeout);
+    if (!wait_result) {
+      GST_DEBUG_OBJECT (comp->parent, "Timeout reached waiting for buffer, returning NULL buffer");
+      _buf = NULL;
+      ret = GST_OMX_ACQUIRE_BUFFER_TIMEOUT;
+      goto done;
+    }
 
     /* And now check everything again and maybe get a buffer */
     goto retry;
diff --git a/omx/gstomx.h b/omx/gstomx.h
index 9ad8e2f..aa10d04 100644
--- a/omx/gstomx.h
+++ b/omx/gstomx.h
@@ -134,7 +134,9 @@ typedef enum {
   /* The port is EOS */
   GST_OMX_ACQUIRE_BUFFER_EOS,
   /* A fatal error happened */
-  GST_OMX_ACQUIRE_BUFFER_ERROR
+  GST_OMX_ACQUIRE_BUFFER_ERROR,
+  /* Buffer coldn't be acquired in the specified time */
+  GST_OMX_ACQUIRE_BUFFER_TIMEOUT
 } GstOMXAcquireBufferReturn;
 
 struct _GstOMXCore {
@@ -328,6 +330,7 @@ OMX_ERRORTYPE     gst_omx_close_tunnel (GstOMXPort * port1, GstOMXPort * port2);
 OMX_ERRORTYPE     gst_omx_port_get_port_definition (GstOMXPort * port, OMX_PARAM_PORTDEFINITIONTYPE * port_def);
 OMX_ERRORTYPE     gst_omx_port_update_port_definition (GstOMXPort *port, OMX_PARAM_PORTDEFINITIONTYPE *port_definition);
 
+GstOMXAcquireBufferReturn gst_omx_port_acquire_buffer_timeout (GstOMXPort *port, GstOMXBuffer **buf, GstClockTime timeout);
 GstOMXAcquireBufferReturn gst_omx_port_acquire_buffer (GstOMXPort *port, GstOMXBuffer **buf);
 OMX_ERRORTYPE     gst_omx_port_release_buffer (GstOMXPort *port, GstOMXBuffer *buf);
 
diff --git a/omx/gstomxvideodec.c b/omx/gstomxvideodec.c
index 2368f34..2251577 100644
--- a/omx/gstomxvideodec.c
+++ b/omx/gstomxvideodec.c
@@ -2211,7 +2211,7 @@ gst_omx_video_dec_handle_frame (GstVideoDecoder * decoder,
      * _loop() can't call _finish_frame() and we might block forever
      * because no input buffers are released */
     GST_VIDEO_DECODER_STREAM_UNLOCK (self);
-    acq_ret = gst_omx_port_acquire_buffer (port, &buf);
+    acq_ret = gst_omx_port_acquire_buffer_timeout (port, &buf, 1 * GST_SECOND);
 
     if (acq_ret == GST_OMX_ACQUIRE_BUFFER_ERROR) {
       GST_VIDEO_DECODER_STREAM_LOCK (self);
@@ -2272,6 +2272,15 @@ gst_omx_video_dec_handle_frame (GstVideoDecoder * decoder,
       /* Now get a new buffer and fill it */
       GST_VIDEO_DECODER_STREAM_LOCK (self);
       continue;
+    } else if (acq_ret == GST_OMX_ACQUIRE_BUFFER_TIMEOUT) {
+      GST_DEBUG_OBJECT (self, "Timeout acquiring buffer");
+      if (self->downstream_flow_ret != GST_FLOW_OK) {
+        gst_video_codec_frame_unref (frame);
+        return self->downstream_flow_ret;
+      } else {
+        GST_DEBUG_OBJECT (self, "No apparent error, let's give it some more time");
+        continue;
+      }
     }
     GST_VIDEO_DECODER_STREAM_LOCK (self);
 
-- 
1.8.3.2

